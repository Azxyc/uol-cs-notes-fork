---
title: COMP109 - Set Operations
tags: COMP109 Lectures
---
## Union
The union of two sets {% raw %}<![CDATA[\(A\)]]>{% endraw %} and {% raw %}<![CDATA[\(B\)]]>{% endraw %} is the set: 
{% raw %}<![CDATA[\[A\cup B = \{x\vert x\in A\ \text{or} \in B\}\]]]>{% endraw %}

This is the same as logical OR ({% raw %}<![CDATA[\(+\)]]>{% endraw %})

### Example  
Suppose
{% raw %}<![CDATA[\[A=\{4,7,8\},\ B=\{4,9,10\}\]]]>{% endraw %} 
Then
{% raw %}<![CDATA[\[A\cup B = \{4,7,8,9,10\}\]]]>{% endraw %}

In bit vectors you just perform a logical OR on both of the bit vectors. The result of the OR is the bit vector of the result of the union.

## Intersection
The intersection of two sets {% raw %}<![CDATA[\(A\)]]>{% endraw %} and {% raw %}<![CDATA[\(B\)]]>{% endraw %} is the set:
{% raw %}<![CDATA[\[A\cap B = \{x\vert x\in A\ \text{and}\ x\in B\}\]]]>{% endraw %}

This is the same as logical AND.

### Example
Suppose
{% raw %}<![CDATA[\[A=\{4,7,8\},\ B=\{4,9,10\}\]]]>{% endraw %} 
Then
{% raw %}<![CDATA[\[A\cap B = \{4\}\]]]>{% endraw %}

In bit vectors the result of the intersection is the same as a logical AND on the bit vectors.

## Relative Complement
The relative complement of a set {% raw %}<![CDATA[\(B\)]]>{% endraw %} to a set {% raw %}<![CDATA[\(A\)]]>{% endraw %} is the set:
{% raw %}<![CDATA[\[A-B=\{x\vert x\in A\ \text{and}\ x\notin B\}\]]]>{% endraw %}

This is the same as XOR ({% raw %}<![CDATA[\(\oplus\)]]>{% endraw %})

This is also sometimes called the set difference.
### Example  
Suppose
{% raw %}<![CDATA[\[A=\{4,7,8\},\ B=\{4,9,10\}\]]]>{% endraw %} 
Then
{% raw %}<![CDATA[\[A - B = \{7,8\}\]]]>{% endraw %}

In bit vectors perform an XOR on both of the bit vectors to get the result.

## Complement
When we are dealing with subsets of some large set {% raw %}<![CDATA[\(U\)]]>{% endraw %}, then we call {% raw %}<![CDATA[\(U\)]]>{% endraw %} the universal set fro the problem in question.

The complement of a set {% raw %}<![CDATA[\(A\)]]>{% endraw %} is the set:
{% raw %}<![CDATA[\[\sim A=\{x\vert x\notin A\}=U-A\]]]>{% endraw %}

This is the same as a binary NOT {% raw %}<![CDATA[\(\neg\)]]>{% endraw %}.

### Example
Let
{% raw %}<![CDATA[\[S=\langle1,2,3,4,5\rangle,\ A=\{1,3,5\}\]]]>{% endraw %}
Then
{% raw %}<![CDATA[\[\sim A = \{2,4\}\]]]>{% endraw %}

## The Symmetric Difference
The symmetric difference of two sets {% raw %}<![CDATA[\(A\)]]>{% endraw %} and {% raw %}<![CDATA[\(B\)]]>{% endraw %} is the set:
{% raw %}<![CDATA[\[A\Delta B=\{x\vert (x\in A\ \text{and}\ x \notin B)\ \text{or}\ (x\notin A\ \text{and}\ x \notin B)\} \]]]>{% endraw %}

This is the same as the logical operator NAND.

### Example  
Suppose
{% raw %}<![CDATA[\[A=\{4,7,8\},\ B=\{4,9,10\}\]]]>{% endraw %} 
Then
{% raw %}<![CDATA[\[A - B = \{7,8,9,10\}\]]]>{% endraw %}

In bit vectors perform an NAND on both of the bit vectors to get the result.

### Proving the Identity of {% raw %}<![CDATA[\(A\Delta B=(A\cup B)-(A\cap B)\)]]>{% endraw %}
#### Proof
Suppose that {% raw %}<![CDATA[\(x\)]]>{% endraw %} is a particular but arbitrarily chosen element. Consider all cases of this element:

##### Case 1
{% raw %}<![CDATA[\(x\notin A,\ x\notin B\)]]>{% endraw %}. By definition of {% raw %}<![CDATA[\(\Delta,\ x\notin A\Delta B\)]]>{% endraw %}.

By definition of {% raw %}<![CDATA[\(\cup,\ x\notin A\cup B\)]]>{% endraw %}.

Hence {% raw %}<![CDATA[\((A\cup B)-(A\cap B)\)]]>{% endraw %}.

##### Case 2
{% raw %}<![CDATA[\(x\in A,\ x\notin B\)]]>{% endraw %}. By definition of {% raw %}<![CDATA[\(\Delta,\ x\in A\Delta B\)]]>{% endraw %}

By definition of {% raw %}<![CDATA[\(\cup,\ x\in A\cup B\)]]>{% endraw %} as {% raw %}<![CDATA[\(x\in A\)]]>{% endraw %}. 

As {% raw %}<![CDATA[\(x\notin B,\ x\notin A\cap B\)]]>{% endraw %}. 

So {% raw %}<![CDATA[\(x\in(A\cup B)-(A\cap B)\)]]>{% endraw %}.

##### Case 3
{% raw %}<![CDATA[\(x\notin A,\ x\in B\)]]>{% endraw %}. This case is symmetric to case 2.

##### Case 4
{% raw %}<![CDATA[\(x\in A,\ x\in B\)]]>{% endraw %}. By definition of {% raw %}<![CDATA[\(\Delta,\ x\notin A\Delta B\)]]>{% endraw %}.

As {% raw %}<![CDATA[\(x\in A\)]]>{% endraw %}, by definition of {% raw %}<![CDATA[\(\cup,\ x\in A\cup B\)]]>{% endraw %}.

As {% raw %}<![CDATA[\(x\in A,\ x\in B,\ x\in A\cap B\)]]>{% endraw %}.

So {% raw %}<![CDATA[\(x\notin (A\cup B)-(A\cap B)\)]]>{% endraw %}.

By the generalisation from the generic particular principle, the identity holds.

(As both sides are equal for all cases the identity must be valid.)
