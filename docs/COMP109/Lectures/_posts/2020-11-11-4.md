---
title: COMP109 - Functions - 2
tags: COMP109 Lectures
---
## Injective (one-to-one) Functions
Let {% raw %}<![CDATA[\(f:A\rightarrow B\)]]>{% endraw %} be a function. We call {% raw %}<![CDATA[\(f\)]]>{% endraw %} and injective, or one-to-one, function if:

{% raw %}<![CDATA[\[f(a_1)=f(a_2)\Rightarrow a_1 = a_2 \text{ for all } a_1,a_2\in A\]]]>{% endraw %}

This is logically equivalent to {% raw %}<![CDATA[\(a_1\neq a_2 \Rightarrow f(a_1) \neq f(a_2)\)]]>{% endraw %} and so injective functions never repeat values. In other words:

Different inputs give different outputs.
{:.info}

### Example 1
{% raw %}<![CDATA[\(f:\mathbb{Z}\rightarrow \mathbb{Z}\)]]>{% endraw %} given by {% raw %}<![CDATA[\(f(x)=x^2\)]]>{% endraw %} is not injective.

{% raw %}<![CDATA[\(h:\mathbb{Z}\rightarrow \mathbb{Z}\)]]>{% endraw %} given by {% raw %}<![CDATA[\(h(x)=2x\)]]>{% endraw %} is injective.

### Example 2
To prove that a function is not injective you can give an individual example of a double mapping.

Take the following question foe the opposite:

{% raw %}<![CDATA[\(h:\mathbb{Z}\rightarrow \mathbb{Z}\)]]>{% endraw %} given by {% raw %}<![CDATA[\(h(x)=2x\)]]>{% endraw %} is injective.

#### Proof
Suppose for a proof by contradiction that there exist {% raw %}<![CDATA[\(a_1,a_2\)]]>{% endraw %} such that {% raw %}<![CDATA[\(h(a_1=h(a_2)\)]]>{% endraw %} and {% raw %}<![CDATA[\(a_1\neq a_2\)]]>{% endraw %}.

{% raw %}<![CDATA[\(2\times a_1 = 2a_2 \Rightarrow a_1 = a_2\)]]>{% endraw %}, a contradiction.

## Surjective (or onto) Functions
{% raw %}<![CDATA[\(f:A\rightarrow B\)]]>{% endraw %} is surjective, or onto, if the range of {% raw %}<![CDATA[\(f\)]]>{% endraw %} coincides with the co-domain {% raw %}<![CDATA[\(f\)]]>{% endraw %}. This means that for every {% raw %}<![CDATA[\(b\in B\)]]>{% endraw %} there exists an {% raw %}<![CDATA[\(a\in A\)]]>{% endraw %} with {% raw %}<![CDATA[\(b=f(a)\)]]>{% endraw %}.

### Examples
{% raw %}<![CDATA[\(h:\mathbb{Z}\rightarrow \mathbb{Z}\)]]>{% endraw %} given by {% raw %}<![CDATA[\(h(x)=2x\)]]>{% endraw %} is not surjective.

This is because you get every even values out as an answer.

{% raw %}<![CDATA[\(h':\mathbb{Q}\rightarrow \mathbb{Q}\)]]>{% endraw %} given by {% raw %}<![CDATA[\(h'(x)=2x\)]]>{% endraw %} is surjective.

This is as you can use rational numbers to make any other number when doubled.

## Question
Classify {% raw %}<![CDATA[\(f:\{a,b,c\}\rightarrow\{1,2,3\}\)]]>{% endraw %} given by:

```mermaid
graph LR
subgraph x
a
b
c
end
subgraph fx
1
2
3
end
a --> 1
b --> 1
c --> 3
2
```

* It is a function.
* Not injective, {% raw %}<![CDATA[\(f(a)=f(b)=1\)]]>{% endraw %}
* Not subjective as no {% raw %}<![CDATA[\(x\)]]>{% endraw %} maps with {% raw %}<![CDATA[\(f(x)=2\)]]>{% endraw %}.

## Bijections
We call {% raw %}<![CDATA[\(f\)]]>{% endraw %} bijective if {% raw %}<![CDATA[\(f\)]]>{% endraw %} is both injective and surjective.

### Examples
{% raw %}<![CDATA[\(f:\mathbb{Q}\rightarrow \mathbb{Q}\)]]>{% endraw %} given by {% raw %}<![CDATA[\(f(x)=2x\)]]>{% endraw %} is bijective.

## Inverse Functions
If {% raw %}<![CDATA[\(f\)]]>{% endraw %} is a bijection from a set {% raw %}<![CDATA[\(X\)]]>{% endraw %} to a set {% raw %}<![CDATA[\(Y\)]]>{% endraw %}, then there is a function {% raw %}<![CDATA[\(f^{-1}\)]]>{% endraw %} from {% raw %}<![CDATA[\(Y\)]]>{% endraw %} to {% raw %}<![CDATA[\(X\)]]>{% endraw %} that undoes the action of {% raw %}<![CDATA[\(f\)]]>{% endraw %}; that is, it sends each element of {% raw %}<![CDATA[\(Y\)]]>{% endraw %} back to the element of {% raw %}<![CDATA[\(X\)]]>{% endraw %} that it came from. This function is called the inverse function for {% raw %}<![CDATA[\(f\)]]>{% endraw %}.

Then {% raw %}<![CDATA[\(f(a)=b\)]]>{% endraw %} if, and only if, {% raw %}<![CDATA[\(f^{-1}(b)=a\)]]>{% endraw %}

### Example
{% raw %}<![CDATA[\(k:\mathbb{R}\rightarrow \mathbb{R}\)]]>{% endraw %} given by {% raw %}<![CDATA[\(k(x)=4x+3\)]]>{% endraw %} is invertible and {% raw %}<![CDATA[\(k^{-1}(y)=\frac{1}{4}(y-3)\)]]>{% endraw %}. 

{% raw %}<![CDATA[\(y=4x+3\)]]>{% endraw %}. So {% raw %}<![CDATA[\(4x+3=y\)]]>{% endraw %}, {% raw %}<![CDATA[\(4x=y-3\)]]>{% endraw %}, {% raw %}<![CDATA[\(x = \frac{y-3}{4}\)]]>{% endraw %}

This proves the statement by giving the same value.
