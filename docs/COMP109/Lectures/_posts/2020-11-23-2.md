---
title: COMP109 - Relations - 3
tags: COMP109 Lectures
---
## Building New Relations from Given Ones
### Inverse Relation
Given a realtion {% raw %}<![CDATA[\(R\subseteq A \times B\)]]>{% endraw %}. We define the inverse relation {% raw %}<![CDATA[\(R^{-1}\subset B\times A\)]]>{% endraw %} by:

{% raw %}<![CDATA[\[R^{-1}=\{(b,a)\vert (a,b) \in R\}\]]]>{% endraw %}

Example:

* The inverse of the relation *is a parent of* on the set of people is the relation *is a child of*.

In other words if you swap the elements of a given relation you should get the inverse relation.

#### Example
{% raw %}<![CDATA[\(A=\{1,2,3,4\},R=\{(x,y)\vert x\leq y\}\)]]>{% endraw %}

Therefore: 

{% raw %}<![CDATA[\(R=\{(1,1),(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,3),(3,4),(4,4)\}\)]]>{% endraw %}

And:

{% raw %}<![CDATA[\(R=\{(1,1),(2,1),(3,1),(4,1),(2,2),(3,2),(4,2),(3,3),(4,3),(4,4)\}\)]]>{% endraw %}

You could also say:

{% raw %}<![CDATA[\(R^{-1}=\{(y,x)\vert x \leq y\} = \{(u,v)\vert u\geq v\}\)]]>{% endraw %}

In these examples you either swap the predicate to denote the inverse or you swap the evaluation such that it produces the inverse.

### Composition of Relations
Let {% raw %}<![CDATA[\(R\subseteq A\times b\)]]>{% endraw %} and {% raw %}<![CDATA[\(s\subseteq B\times C\)]]>{% endraw %}. The (functional) composition of {% raw %}<![CDATA[\(R\)]]>{% endraw %} and {% raw %}<![CDATA[\(S\)]]>{% endraw %}, denoted by {% raw %}<![CDATA[\(S\circ R\)]]>{% endraw %}, is the binary relation between {% raw %}<![CDATA[\(A\)]]>{% endraw %} and {% raw %}<![CDATA[\(C\)]]>{% endraw %} given by:

{% raw %}<![CDATA[\[S\circ R = \{(a,c)\vert \text{ exists } b\in B \text{ such that } aRb \text{ and } bSc\}\]]]>{% endraw %}

The notation {% raw %}<![CDATA[\(aRb\)]]>{% endraw %} is another way of writing {% raw %}<![CDATA[\((a,b)\in R\)]]>{% endraw %}.
{:.info}

```mermaid
graph LR
subgraph A
a[1]
end
subgraph B
b[ ]
end
subgraph C
c[2]
end 
a -->|R subset A * B| b
b -->|S subset B * C| c
```

Example:

* If {% raw %}<![CDATA[\(R\)]]>{% endraw %} is the relation *is a sister of* and {% raw %}<![CDATA[\(S\)]]>{% endraw %} is the relation *is a parent of* then:
	* {% raw %}<![CDATA[\(S\circ R\)]]>{% endraw %} is the relation *is an aunt of*.
	* {% raw %}<![CDATA[\(S\circ S\)]]>{% endraw %} is the relation *is a grandparent of*.
	
#### Example

* {% raw %}<![CDATA[\(R:\)]]>{% endraw %} is a sister of
* {% raw %}<![CDATA[\(S:\)]]>{% endraw %} is a parent of
* {% raw %}<![CDATA[\(S\circ R=\{(a,c)\vert\text{ exists } b\in B\text{ such that } aRb \text{ and } bSc\}\)]]>{% endraw %}

```mermaid
graph TD
fm[Fred and Mavis] --- Alice
fm --- ks[Ken and Sue]
ks --- Jane
ks --- Fiona
ks --- Alan
jm[John and Mary] --- ks
jm --- Mike
jm --- Penny
```

* Alice {% raw %}<![CDATA[\(R\)]]>{% endraw %} Ken and Ken {% raw %}<![CDATA[\(S\)]]>{% endraw %} Alan so Alice {% raw %}<![CDATA[\(S\circ R\)]]>{% endraw %} Alan.
	* This can also be written as {% raw %}<![CDATA[\((\text{Alice, Alan})\in S\circ R\)]]>{% endraw %}
	
#### Diagraph Representation of Compositions

For this diagram {% raw %}<![CDATA[\(A=\{a,b\},B=\{1,2,3\},C=\{x,y\}\)]]>{% endraw %}:

```mermaid
graph LR
subgraph R
a --> 1
a --> 2
b --> 2
a --> 3
end
subgraph S
12[1] --> y
22[2] --> x
32[3] --> x
end 
subgraph S circ R
a2[a] --> x2[x]
a2 --> y2[y]
b2[b] --> x2
end
1 --> 12
2 --> 22
3 --> 32
```

## Computer Friendly Representation of Binary Relations - Matrices

Let {% raw %}<![CDATA[\(A=\{a_1,\ldots,a_n\},B=\{b_1,\ldots,b_m\}\)]]>{% endraw %} and {% raw %}<![CDATA[\(R\subseteq A\times B\)]]>{% endraw %}.

We represent {% raw %}<![CDATA[\(R\)]]>{% endraw %} by an array {% raw %}<![CDATA[\(M\)]]>{% endraw %} of {% raw %}<![CDATA[\(n\)]]>{% endraw %} rows and {% raw %}<![CDATA[\(m\)]]>{% endraw %} columns. Such an array is called an {% raw %}<![CDATA[\(n\)]]>{% endraw %} by {% raw %}<![CDATA[\(m\)]]>{% endraw %} matrix.

The entry in row {% raw %}<![CDATA[\(i\)]]>{% endraw %} and column {% raw %}<![CDATA[\(j\)]]>{% endraw %} of this matrix is given by {% raw %}<![CDATA[\(M(i,j)\)]]>{% endraw %} where:

{% raw %}<![CDATA[\[
M(i,j)=\begin{cases}
1 & \text{ if } (a_i,b_j)\in R\\
0 & \text{ if } (a_1,b_j)\notin R
\end{cases}
\]]]>{% endraw %}

### Example 1
Let {% raw %}<![CDATA[\(A=\{1,3,5,7\}, B=\{2,4,6\}\)]]>{% endraw %} and:

{% raw %}<![CDATA[\[U=\{(x,y)\in A\times B\vert x + y = 9\}\]]]>{% endraw %}

Assume an enumeration {% raw %}<![CDATA[\(a_1=1,a_2=3,a_3=5,a_4=7\)]]>{% endraw %} and {% raw %}<![CDATA[\(b_1=2,b_2=4,b_3=6\)]]>{% endraw %}. Then {% raw %}<![CDATA[\(M\)]]>{% endraw %} represents {% raw %}<![CDATA[\(U\)]]>{% endraw %}, where:

{% raw %}<![CDATA[\[
M = \begin{bmatrix}
0 & 0 & 0\\
0 & 0 & 1\\
0 & 1 & 0\\
1 & 0 & 0
\end{bmatrix}
\]]]>{% endraw %}

When representing in a matrix the rows are the items in set {% raw %}<![CDATA[\(A\)]]>{% endraw %} going down and the columns are the items in set {% raw %}<![CDATA[\(B\)]]>{% endraw %} going across.
{:.info}

You can then read the answers from the matrix as: {% raw %}<![CDATA[\(U=\{(7,2),(5,4),(4,6)\}\)]]>{% endraw %}.

### Example 2
The binary relation {% raw %}<![CDATA[\(R\)]]>{% endraw %} on {% raw %}<![CDATA[\(A=\{1,2,3,4\}\)]]>{% endraw %} has the following digraph representation:

```mermaid
graph LR
4 --> 3
3 --> 2
2 --> 1
```

1. What are the ordered pairs?
	
	{% raw %}<![CDATA[\(R=\{(4,3),(3,2),(2,1)\}\)]]>{% endraw %}
1. Draw the matrix.
	
	{% raw %}<![CDATA[\[
	\begin{bmatrix}
	0&0&0&0\\
	1&0&0&0\\
	0&1&0&0\\
	0&0&1&0
	\end{bmatrix}
	\]]]>{% endraw %}
1. Explain the relation.

	{% raw %}<![CDATA[\(x\)]]>{% endraw %} is 1 larger than {% raw %}<![CDATA[\(y\)]]>{% endraw %}.

### Matrices and Composition
This is working on the same relation as was seen in the section [Diagraph Representation of Compositions](#diagraph-representation-of-compositions).

```mermaid
graph LR
subgraph X
a
b
end
subgraph Y
1
2
3
end
subgraph Z
x
y
end
a --> 1
a --> 2
a --> 3
b --> 2
1 --> y
2 --> x
3 --> x
```

This result in the following for the composition of {% raw %}<![CDATA[\(S\circ R\)]]>{% endraw %}:

```mermaid
graph LR
a --> x
a --> y
b --> x
```

From these graphs we can deduce that {% raw %}<![CDATA[\(R\subseteq X\times Y, S\subseteq Y\times Z\)]]>{% endraw %}.

Given the matrices of {% raw %}<![CDATA[\(R\)]]>{% endraw %} and {% raw %}<![CDATA[\(S\)]]>{% endraw %}:

{% raw %}<![CDATA[\[
R: \begin{bmatrix}
1&1&1\\
0&1&0
\end{bmatrix}
S: \begin{bmatrix}
0&1\\
1&0\\
1&0
\end{bmatrix}
\]]]>{% endraw %}

Calculate the binary relation matrix of {% raw %}<![CDATA[\(S\circ R\)]]>{% endraw %}:

If you transpose the row {% raw %}<![CDATA[\(a\)]]>{% endraw %} in the matrix {% raw %}<![CDATA[\(R\)]]>{% endraw %} on the column {% raw %}<![CDATA[\(x\)]]>{% endraw %} in the matrix {% raw %}<![CDATA[\(S\)]]>{% endraw %} you can compare to see of {% raw %}<![CDATA[\(a\)]]>{% endraw %} is a subset of {% raw %}<![CDATA[\(y\)]]>{% endraw %}. If it is then you put a 1 in the resultant matrix and if not you put a zero:

{% raw %}<![CDATA[\[
S\circ R:\begin{bmatrix}
1&1\\
1&0
\end{bmatrix}
\]]]>{% endraw %}

#### Boolean Matrix Product
Given two matrices with entries 1 and 0 representing the relations we can form the matrix representing the composition. This is called the logical (Boolean) matrix product.

Let {% raw %}<![CDATA[\(A=\{a_1,\ldots,a_n\},B=\{b_1,\ldots,b_m\}\)]]>{% endraw %} and {% raw %}<![CDATA[\(C=\{c_1,\ldots,c_p\}\)]]>{% endraw %}.

The logical matrix {% raw %}<![CDATA[\(M\)]]>{% endraw %} representing {% raw %}<![CDATA[\(R\)]]>{% endraw %} is given by:

{% raw %}<![CDATA[\[
M(i,j)=\begin{cases}
1 & \text{ if } (a_i,b_j)\in R\\
0 & \text{ if } (a_1,b_j)\notin R
\end{cases}
\]]]>{% endraw %}

The logical matrix {% raw %}<![CDATA[\(N\)]]>{% endraw %} representing {% raw %}<![CDATA[\(S\)]]>{% endraw %} is given by:

{% raw %}<![CDATA[\[
N(i,j)=\begin{cases}
1 & \text{ if } (b_i,c_j)\in S\\
0 & \text{ if } (b_1,c_j)\notin S
\end{cases}
\]]]>{% endraw %}

Then the entries {% raw %}<![CDATA[\(P(i,)\)]]>{% endraw %} of the logical matrix {% raw %}<![CDATA[\(P\)]]>{% endraw %} representing {% raw %}<![CDATA[\(S\circ R\)]]>{% endraw %} are given by:

* {% raw %}<![CDATA[\(P(i,j)=1\)]]>{% endraw %} if there existsw {% raw %}<![CDATA[\(l\)]]>{% endraw %} with {% raw %}<![CDATA[\(1\leq l\leq m\)]]>{% endraw %} such that {% raw %}<![CDATA[\(M(i,l)=1\)]]>{% endraw %} and {% raw %}<![CDATA[\(N(i,j)=1\)]]>{% endraw %}.
* {% raw %}<![CDATA[\(P(i,j)=0\)]]>{% endraw %}, otherwise.

This is the same as a product of matrices, {% raw %}<![CDATA[\(P=MN\)]]>{% endraw %}. Instead of addition and multiplication we use logical OR and AND.
