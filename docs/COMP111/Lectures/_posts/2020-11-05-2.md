---
title: COMP111 - Rule Based Languages
tags: COMP111 Lectures
---
## Syntax
An **individual name** denote an individual object. They are also called **constant symbols**:

* England
* We also use lower case letters: {% raw %}<pre>\(a,b,c,a_1,a_2,\ldots\)</pre>{% endraw %}

An **individual variable** is a placeholder for an individual name. They are denoted by lower case letters:

* {% raw %}<pre>\(x,y,z,x_1,x_2,\ldots\)</pre>{% endraw %}

A **class name** denotes a set of individual objects. They are often also called **unary predicate symbols**:

* Human_Being
* We also often use upper case letters such as {% raw %}<pre>\(A,B,C,A_1,A_2\)</pre>{% endraw %}

### Atomic Assertions

An atomic assertion takes the form {% raw %}<pre>\(A(b)\)</pre>{% endraw %} and state the {% raw %}<pre>\(b\)</pre>{% endraw %} is in the class {% raw %}<pre>\(A\)</pre>{% endraw %}:

* The assertion,
{% raw %}<pre>\[\text{CompetesInPremierLeague}(\text{LiverpoolFC})\]</pre>{% endraw %} states that Liverpool FC competes in the Premier League.

### Unary Rule
A unary rule take the form:
{% raw %}<pre>\[A_1(x)\wedge\ldots\wedge A_n(x)\rightarrow A(x)\]</pre>{% endraw %}
Where {% raw %}<pre>\(A_1,ldots,A_n\)</pre>{% endraw %} and {% raw %}<pre>\(A\)</pre>{% endraw %} are class names and {% raw %}<pre>\(x\)</pre>{% endraw %} is an individual variable.

* The {% raw %}<pre>\(\wedge\)</pre>{% endraw %} symbol is the symbol for logical AND.
* The {% raw %}<pre>\(\rightarrow\)</pre>{% endraw %} symbol means **implies that**.

The rule states the everything in all classes {% raw %}<pre>\(A_1,A_2,\ldots,A_n\)</pre>{% endraw %} is in the class A.

#### Example

The rule:
{% raw %}<pre>\[\text{Disease}(x)\wedge\text{LocatedInHeart}(x)\rightarrow\text{HeartDisease}(x)\]</pre>{% endraw %}
states that every disease located in the heart is a heart disease.

You can also say that the result of the evaluation on the left side is a subset of the objects in the set on the right hand side.

#### Unary Rule-Based Systems
A unary rule-based knowledge base {% raw %}<pre>\(K\)</pre>{% endraw %} is a collection {% raw %}<pre>\(K_a\)</pre>{% endraw %} of **atomic assertions** and {% raw %}<pre>\(K_r\)</pre>{% endraw %} of **unary rules**.

##### Example
Let {% raw %}<pre>\(K_a\)</pre>{% endraw %} contain the following atomic assertions:

* {% raw %}<pre>\(\text{CompetesInPremierLeague}(\text{LiverpoolFC})\)</pre>{% endraw %}
* {% raw %}<pre>\(\text{CompetesInPremierLeague}(\text{Everton})\)</pre>{% endraw %} and so on for all members of the class {% raw %}<pre>\(\text{CompetesInPremierLeague}\)</pre>{% endraw %}

Let {% raw %}<pre>\(K_r\)</pre>{% endraw %} contain the following rules:

* {% raw %}<pre>\(\text{CompetesInPremierLeague}(x)\rightarrow\text{CompetesInFACup}(x)\)</pre>{% endraw %}
* {% raw %}<pre>\(\text{CompetesInPremierLeague}(x)\rightarrow\text{FootballClub}(x)\)</pre>{% endraw %}
* {% raw %}<pre>\(\text{CompetesInPremierLeague}(x)\rightarrow\text{BasedInEngland}(x)\)</pre>{% endraw %}

The follwoing atomic asseritons follow from {% raw %}<pre>\(K\)</pre>{% endraw %}:

* {% raw %}<pre>\(\text{CompetesInFACup}(\text{LiverpoolFC})\)</pre>{% endraw %}
* {% raw %}<pre>\(\text{FootBallClub}(\text{Everton})\)</pre>{% endraw %}, and so on.

Thus from 20 facts and 3 rules, we can deduce 60 additional facts. This allows us to store much more data in a compact way.

## Reasoning in Rule-Based Systems
Let {% raw %}<pre>\(K\)</pre>{% endraw %} be a knowledge base and {% raw %}<pre>\(A(b)\)</pre>{% endraw %} an atomic assertion. Then {% raw %}<pre>\(A(b)\)</pre>{% endraw %} **follows from** {% raw %}<pre>\(K\)</pre>{% endraw %}:
{% raw %}<pre>\[K\models A(b)\]</pre>{% endraw %}

You can also say that {% raw %}<pre>\(K\)</pre>{% endraw %} **models** {% raw %}<pre>\(A(b)\)</pre>{% endraw %}.

This means that whenever {% raw %}<pre>\(K\)</pre>{% endraw %} is true, then {% raw %}<pre>\(A(b)\)</pre>{% endraw %} is true. If that is not the case you can write {% raw %}<pre>\(K\nvDash A(b)\)</pre>{% endraw %}.

### Example 1
In the example {% raw %}<pre>\(K\)</pre>{% endraw %} earlier:
{% raw %}<pre>\[K\models\text{CompetesInFACup}(\text{LiverpoolFC})\]</pre>{% endraw %}

### Example 2
Let:

* {% raw %}<pre>\(K_a=\{A_1(a)\}\)</pre>{% endraw %}
* {% raw %}<pre>\(K_r=\{A_1(a)\rightarrow A_2(x),A_2(x)\rightarrow A_3(x)\}\)</pre>{% endraw %}

Let {% raw %}<pre>\(K\)</pre>{% endraw %} contain {% raw %}<pre>\(K_a\)</pre>{% endraw %} and {% raw %}<pre>\(K_r\)</pre>{% endraw %}. Then:

* {% raw %}<pre>\(K\models A_1(a)\)</pre>{% endraw %}
* {% raw %}<pre>\(K\models A_2(a)\)</pre>{% endraw %}
* {% raw %}<pre>\(K\models A_3(a)\)</pre>{% endraw %}

This chaining shows that if {% raw %}<pre>\(a\)</pre>{% endraw %} is in {% raw %}<pre>\(A_1\)</pre>{% endraw %} then is also in {% raw %}<pre>\(A_2\)</pre>{% endraw %} and so on.
