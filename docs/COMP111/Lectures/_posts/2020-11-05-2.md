---
title: COMP111 - Rule Based Languages
tags: COMP111 Lectures
---
## Syntax
An **individual name** denote an individual object. They are also called **constant symbols**:

* England
* We also use lower case letters: {% raw %}<![CDATA[\(a,b,c,a_1,a_2,\ldots\)]]>{% endraw %}

An **individual variable** is a placeholder for an individual name. They are denoted by lower case letters:

* {% raw %}<![CDATA[\(x,y,z,x_1,x_2,\ldots\)]]>{% endraw %}

A **class name** denotes a set of individual objects. They are often also called **unary predicate symbols**:

* Human_Being
* We also often use upper case letters such as {% raw %}<![CDATA[\(A,B,C,A_1,A_2\)]]>{% endraw %}

### Atomic Assertions

An atomic assertion takes the form {% raw %}<![CDATA[\(A(b)\)]]>{% endraw %} and state the {% raw %}<![CDATA[\(b\)]]>{% endraw %} is in the class {% raw %}<![CDATA[\(A\)]]>{% endraw %}:

* The assertion,
{% raw %}<![CDATA[\[\text{CompetesInPremierLeague}(\text{LiverpoolFC})\]]]>{% endraw %} states that Liverpool FC competes in the Premier League.

### Unary Rule
A unary rule take the form:
{% raw %}<![CDATA[\[A_1(x)\wedge\ldots\wedge A_n(x)\rightarrow A(x)\]]]>{% endraw %}
Where {% raw %}<![CDATA[\(A_1,ldots,A_n\)]]>{% endraw %} and {% raw %}<![CDATA[\(A\)]]>{% endraw %} are class names and {% raw %}<![CDATA[\(x\)]]>{% endraw %} is an individual variable.

* The {% raw %}<![CDATA[\(\wedge\)]]>{% endraw %} symbol is the symbol for logical AND.
* The {% raw %}<![CDATA[\(\rightarrow\)]]>{% endraw %} symbol means **implies that**.

The rule states the everything in all classes {% raw %}<![CDATA[\(A_1,A_2,\ldots,A_n\)]]>{% endraw %} is in the class A.

#### Example

The rule:
{% raw %}<![CDATA[\[\text{Disease}(x)\wedge\text{LocatedInHeart}(x)\rightarrow\text{HeartDisease}(x)\]]]>{% endraw %}
states that every disease located in the heart is a heart disease.

You can also say that the result of the evaluation on the left side is a subset of the objects in the set on the right hand side.

#### Unary Rule-Based Systems
A unary rule-based knowledge base {% raw %}<![CDATA[\(K\)]]>{% endraw %} is a collection {% raw %}<![CDATA[\(K_a\)]]>{% endraw %} of **atomic assertions** and {% raw %}<![CDATA[\(K_r\)]]>{% endraw %} of **unary rules**.

##### Example
Let {% raw %}<![CDATA[\(K_a\)]]>{% endraw %} contain the following atomic assertions:

* {% raw %}<![CDATA[\(\text{CompetesInPremierLeague}(\text{LiverpoolFC})\)]]>{% endraw %}
* {% raw %}<![CDATA[\(\text{CompetesInPremierLeague}(\text{Everton})\)]]>{% endraw %} and so on for all members of the class {% raw %}<![CDATA[\(\text{CompetesInPremierLeague}\)]]>{% endraw %}

Let {% raw %}<![CDATA[\(K_r\)]]>{% endraw %} contain the following rules:

* {% raw %}<![CDATA[\(\text{CompetesInPremierLeague}(x)\rightarrow\text{CompetesInFACup}(x)\)]]>{% endraw %}
* {% raw %}<![CDATA[\(\text{CompetesInPremierLeague}(x)\rightarrow\text{FootballClub}(x)\)]]>{% endraw %}
* {% raw %}<![CDATA[\(\text{CompetesInPremierLeague}(x)\rightarrow\text{BasedInEngland}(x)\)]]>{% endraw %}

The follwoing atomic asseritons follow from {% raw %}<![CDATA[\(K\)]]>{% endraw %}:

* {% raw %}<![CDATA[\(\text{CompetesInFACup}(\text{LiverpoolFC})\)]]>{% endraw %}
* {% raw %}<![CDATA[\(\text{FootBallClub}(\text{Everton})\)]]>{% endraw %}, and so on.

Thus from 20 facts and 3 rules, we can deduce 60 additional facts. This allows us to store much more data in a compact way.

## Reasoning in Rule-Based Systems
Let {% raw %}<![CDATA[\(K\)]]>{% endraw %} be a knowledge base and {% raw %}<![CDATA[\(A(b)\)]]>{% endraw %} an atomic assertion. Then {% raw %}<![CDATA[\(A(b)\)]]>{% endraw %} **follows from** {% raw %}<![CDATA[\(K\)]]>{% endraw %}:
{% raw %}<![CDATA[\[K\models A(b)\]]]>{% endraw %}

You can also say that {% raw %}<![CDATA[\(K\)]]>{% endraw %} **models** {% raw %}<![CDATA[\(A(b)\)]]>{% endraw %}.

This means that whenever {% raw %}<![CDATA[\(K\)]]>{% endraw %} is true, then {% raw %}<![CDATA[\(A(b)\)]]>{% endraw %} is true. If that is not the case you can write {% raw %}<![CDATA[\(K\nvDash A(b)\)]]>{% endraw %}.

### Example 1
In the example {% raw %}<![CDATA[\(K\)]]>{% endraw %} earlier:
{% raw %}<![CDATA[\[K\models\text{CompetesInFACup}(\text{LiverpoolFC})\]]]>{% endraw %}

### Example 2
Let:

* {% raw %}<![CDATA[\(K_a=\{A_1(a)\}\)]]>{% endraw %}
* {% raw %}<![CDATA[\(K_r=\{A_1(a)\rightarrow A_2(x),A_2(x)\rightarrow A_3(x)\}\)]]>{% endraw %}

Let {% raw %}<![CDATA[\(K\)]]>{% endraw %} contain {% raw %}<![CDATA[\(K_a\)]]>{% endraw %} and {% raw %}<![CDATA[\(K_r\)]]>{% endraw %}. Then:

* {% raw %}<![CDATA[\(K\models A_1(a)\)]]>{% endraw %}
* {% raw %}<![CDATA[\(K\models A_2(a)\)]]>{% endraw %}
* {% raw %}<![CDATA[\(K\models A_3(a)\)]]>{% endraw %}

This chaining shows that if {% raw %}<![CDATA[\(a\)]]>{% endraw %} is in {% raw %}<![CDATA[\(A_1\)]]>{% endraw %} then is also in {% raw %}<![CDATA[\(A_2\)]]>{% endraw %} and so on.
