---
title: COMP111 - Rule Based Languages
tags: COMP111 Lectures
---
## Syntax
An **individual name** denote an individual object. They are also called **constant symbols**:

* England
* We also use lower case letters: `{% raw %}\(a,b,c,a_1,a_2,\ldots\){% endraw %}`

An **individual variable** is a placeholder for an individual name. They are denoted by lower case letters:

* `{% raw %}\(x,y,z,x_1,x_2,\ldots\){% endraw %}`

A **class name** denotes a set of individual objects. They are often also called **unary predicate symbols**:

* Human_Being
* We also often use upper case letters such as `{% raw %}\(A,B,C,A_1,A_2\){% endraw %}`

### Atomic Assertions

An atomic assertion takes the form `{% raw %}\(A(b)\){% endraw %}` and state the `{% raw %}\(b\){% endraw %}` is in the class `{% raw %}\(A\){% endraw %}`:

* The assertion,
`{% raw %}\[\text{CompetesInPremierLeague}(\text{LiverpoolFC})\]{% endraw %}` states that Liverpool FC competes in the Premier League.

### Unary Rule
A unary rule take the form:
`{% raw %}\[A_1(x)\wedge\ldots\wedge A_n(x)\rightarrow A(x)\]{% endraw %}`
Where `{% raw %}\(A_1,ldots,A_n\){% endraw %}` and `{% raw %}\(A\){% endraw %}` are class names and `{% raw %}\(x\){% endraw %}` is an individual variable.

* The `{% raw %}\(\wedge\){% endraw %}` symbol is the symbol for logical AND.
* The `{% raw %}\(\rightarrow\){% endraw %}` symbol means **implies that**.

The rule states the everything in all classes `{% raw %}\(A_1,A_2,\ldots,A_n\){% endraw %}` is in the class A.

#### Example

The rule:
`{% raw %}\[\text{Disease}(x)\wedge\text{LocatedInHeart}(x)\rightarrow\text{HeartDisease}(x)\]{% endraw %}`
states that every disease located in the heart is a heart disease.

You can also say that the result of the evaluation on the left side is a subset of the objects in the set on the right hand side.

#### Unary Rule-Based Systems
A unary rule-based knowledge base `{% raw %}\(K\){% endraw %}` is a collection `{% raw %}\(K_a\){% endraw %}` of **atomic assertions** and `{% raw %}\(K_r\){% endraw %}` of **unary rules**.

##### Example
Let `{% raw %}\(K_a\){% endraw %}` contain the following atomic assertions:

* `{% raw %}\(\text{CompetesInPremierLeague}(\text{LiverpoolFC})\){% endraw %}`
* `{% raw %}\(\text{CompetesInPremierLeague}(\text{Everton})\){% endraw %}` and so on for all members of the class `{% raw %}\(\text{CompetesInPremierLeague}\){% endraw %}`

Let `{% raw %}\(K_r\){% endraw %}` contain the following rules:

* `{% raw %}\(\text{CompetesInPremierLeague}(x)\rightarrow\text{CompetesInFACup}(x)\){% endraw %}`
* `{% raw %}\(\text{CompetesInPremierLeague}(x)\rightarrow\text{FootballClub}(x)\){% endraw %}`
* `{% raw %}\(\text{CompetesInPremierLeague}(x)\rightarrow\text{BasedInEngland}(x)\){% endraw %}`

The follwoing atomic asseritons follow from `{% raw %}\(K\){% endraw %}`:

* `{% raw %}\(\text{CompetesInFACup}(\text{LiverpoolFC})\){% endraw %}`
* `{% raw %}\(\text{FootBallClub}(\text{Everton})\){% endraw %}`, and so on.

Thus from 20 facts and 3 rules, we can deduce 60 additional facts. This allows us to store much more data in a compact way.

## Reasoning in Rule-Based Systems
Let `{% raw %}\(K\){% endraw %}` be a knowledge base and `{% raw %}\(A(b)\){% endraw %}` an atomic assertion. Then `{% raw %}\(A(b)\){% endraw %}` **follows from** `{% raw %}\(K\){% endraw %}`:
`{% raw %}\[K\models A(b)\]{% endraw %}`

You can also say that `{% raw %}\(K\){% endraw %}` **models** `{% raw %}\(A(b)\){% endraw %}`.

This means that whenever `{% raw %}\(K\){% endraw %}` is true, then `{% raw %}\(A(b)\){% endraw %}` is true. If that is not the case you can write `{% raw %}\(K\nvDash A(b)\){% endraw %}`.

### Example 1
In the example `{% raw %}\(K\){% endraw %}` earlier:
`{% raw %}\[K\models\text{CompetesInFACup}(\text{LiverpoolFC})\]{% endraw %}`

### Example 2
Let:

* `{% raw %}\(K_a=\{A_1(a)\}\){% endraw %}`
* `{% raw %}\(K_r=\{A_1(a)\rightarrow A_2(x),A_2(x)\rightarrow A_3(x)\}\){% endraw %}`

Let `{% raw %}\(K\){% endraw %}` contain `{% raw %}\(K_a\){% endraw %}` and `{% raw %}\(K_r\){% endraw %}`. Then:

* `{% raw %}\(K\models A_1(a)\){% endraw %}`
* `{% raw %}\(K\models A_2(a)\){% endraw %}`
* `{% raw %}\(K\models A_3(a)\){% endraw %}`

This chaining shows that if `{% raw %}\(a\){% endraw %}` is in `{% raw %}\(A_1\){% endraw %}` then is also in `{% raw %}\(A_2\){% endraw %}` and so on.
