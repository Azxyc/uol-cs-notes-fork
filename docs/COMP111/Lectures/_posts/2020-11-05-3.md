---
title: COMP111 - Derived Assertions Algorithm
tags: COMP111 Lectures
---
The following algorithm take as input the knowledge base {% raw %}<pre>\(K\)</pre>{% endraw %} containing {% raw %}<pre>\(K_a\)</pre>{% endraw %} and {% raw %}<pre>\(K_r\)</pre>{% endraw %} and computes all assertions {% raw %}<pre>\(E(a)\)</pre>{% endraw %} with {% raw %}<pre>\(E\)</pre>{% endraw %} a class name and {% raw %}<pre>\(a\)</pre>{% endraw %} an individual name such that {% raw %}<pre>\(K\models E(a)\)</pre>{% endraw %}. This set is stored in: {% raw %}<pre>\[\text{DerivedAssertions}\]</pre>{% endraw %} In only remains to check whether {% raw %}<pre>\(A(b)\)</pre>{% endraw %} is in {% raw %}<pre>\(\text{DerivedAssertions}\)</pre>{% endraw %}. 

The algorithm computes the set {% raw %}<pre>\(\text{DerivedAssertions}\)</pre>{% endraw %} by starting with {% raw %}<pre>\(K_a\)</pre>{% endraw %} and then applying the rules {% raw %}<pre>\(K_r\)</pre>{% endraw %} exhaustively to already derived atomic assertions.

```
Input: a knowledge base K containing assertions K_a and rules K_r
	
DerivedAssertions := K_a
repeat
	if there exits E(a) not in DerivedAssertions
		and A_1(x)^...^A_n(x) --> E(x) in K_r
		and A_1(x),...,A_n(x) in DerivedAssertions
	then 
		add E(a) to DerivedAssertions
		NewAssertion := true
	else 
		NewAssertion := false
	endif
until NewAssertion = false
return Derived Assertions
```

## Rule Application
In the algorithm above we say that:

{% raw %}<pre>\(E(a)\)</pre>{% endraw %} is added to {% raw %}<pre>\(\text{DerivedAssertions}\)</pre>{% endraw %} by applying the rule:
{% raw %}<pre>\[A_1(x)\wedge\ldots\wedge A_n\rightarrow E(x)\]</pre>{% endraw %}
to the atomic assertions:
{% raw %}<pre>\[A_1(x),\ldots,A_n\in\text{DerivedAssertions}\]</pre>{% endraw %}

### Example
Let:

* {% raw %}<pre>\(K_a=\{A_1(a)\}\)</pre>{% endraw %}
* {% raw %}<pre>\(K_a=\{A_1(x)\rightarrow A_2(x),A_2(x)\rightarrow A_3(x)\}\)</pre>{% endraw %}

In:

* First {% raw %}<pre>\(\text{DerivedAssertions}\)</pre>{% endraw %} contains {% raw %}<pre>\(K_a\)</pre>{% endraw %} only.

* Then an application of {% raw %}<pre>\(A_1(x)\rightarrow A_2(x)\)</pre>{% endraw %} to {% raw %}<pre>\(A_1(a)\)</pre>{% endraw %} adds {% raw %}<pre>\(A_2(a)\)</pre>{% endraw %} to {% raw %}<pre>\(\text{DerivedAssertions}\)</pre>{% endraw %}.

* Then an application of {% raw %}<pre>\(A_2(x)\rightarrow A_3(x)\)</pre>{% endraw %} to {% raw %}<pre>\(A_2(a)\)</pre>{% endraw %} adds {% raw %}<pre>\(A_3(a)\)</pre>{% endraw %} to {% raw %}<pre>\(\text{DerivedAssertions}\)</pre>{% endraw %}.

* Now no rule is applicable. Thus:
{% raw %}<pre>\[\text{DerivedAssertions}=\{A_1(a),A_2(a),A_3(a)\}\]</pre>{% endraw %}
is returned.
