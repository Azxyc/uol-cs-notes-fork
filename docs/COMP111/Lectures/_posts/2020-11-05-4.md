---
title: COMP111 - Relations & Non-Unary Rule-Based Systems
tags: COMP111 Lectures
---
You cannot express relations between objects using the concepts we have learned so far. **Relations** are expressed as such: 

* A **relation name** {% raw %}<pre>\(R\)</pre>{% endraw %} denotes a set of **pairs** of individual object. Relation names are also called **binary predicates**: 
	* {% raw %}<pre>\(\text{sonOf}\)</pre>{% endraw %}
	* {% raw %}<pre>\(\text{grandsonOf}\)</pre>{% endraw %}
	* These call also be denotes by upper case letters {% raw %}<pre>\(R,S,R_1,R_2\)</pre>{% endraw %} and so on.
	
To express that an individual object {% raw %}<pre>\(a\)</pre>{% endraw %} is in the relation {% raw %}<pre>\(R\)</pre>{% endraw %} to an individual object {% raw %}<pre>\(b\)</pre>{% endraw %} we write {% raw %}<pre>\(R(a,b)\)</pre>{% endraw %}. {% raw %}<pre>\(R(a,b)\)</pre>{% endraw %} is *also* called an **atomic assertion**. This can also be read as {% raw %}<pre>\(a\)</pre>{% endraw %} is in relation {% raw %}<pre>\(R\)</pre>{% endraw %} to {% raw %}<pre>\(b\)</pre>{% endraw %}:

* {% raw %}<pre>\(\text{sonOf(Peter, John)}\)</pre>{% endraw %}, where {% raw %}<pre>\(\text{Peter}\)</pre>{% endraw %} is the son of {% raw %}<pre>\(\text{John}\)</pre>{% endraw %}.

## Rule-Based Systems
A rule has the form:
{% raw %}<pre>\[R_1(x_1,y_1)\wedge\ldots\wedge R_n(x_n,y_n)\wedge A_1(x_{n+1})\wedge\ldots\wedge A_m(x_{n+m})\rightarrow R(x,y)\]</pre>{% endraw %}
or
{% raw %}<pre>\[R_1(x_1,y_1)\wedge\ldots\wedge R_n(x_n,y_n)\wedge A_1(x_{n+1})\wedge\ldots\wedge A_m(x_{n+m})\rightarrow A(x)\]</pre>{% endraw %}
Where:

* {% raw %}<pre>\(R_1,\ldots,R_n\)</pre>{% endraw %} and {% raw %}<pre>\(R\)</pre>{% endraw %} are relation names.
* {% raw %}<pre>\(A_1,\ldots,A_n\)</pre>{% endraw %} and {% raw %}<pre>\(A\)</pre>{% endraw %} are class names.
* {% raw %}<pre>\(x_1,y_1,\ldots,x_n,y_n,x_{n+1},\ldots,x_{n+m},x,y\)</pre>{% endraw %} are individual variables.

A rule-based knowledge base {% raw %}<pre>\(K\)</pre>{% endraw %} is a collection {% raw %}<pre>\(K_a\)</pre>{% endraw %} of atomic assertions and {% raw %}<pre>\(K_r\)</pre>{% endraw %} of rules.

### Example

Consider the following set {% raw %}<pre>\(K_a\)</pre>{% endraw %} of atomic assertions:

* {% raw %}<pre>\(\text{sonOf(Peter, John)}\)</pre>{% endraw %}
* {% raw %}<pre>\(\text{sonOf(John, Joseph)}\)</pre>{% endraw %}

Consider the following set {% raw %}<pre>\(K_r\)</pre>{% endraw %} of rules:

* {% raw %}<pre>\(\text{sonOf}(x,y)\wedge\text{sonOf}(y,z)\rightarrow\text{grandsonOf}(x,z)\)</pre>{% endraw %}

Then {% raw %}<pre>\(\text{grandsonOf(Peter, Joseph)}\)</pre>{% endraw %} follows from {% raw %}<pre>\(K\)</pre>{% endraw %}, in symbols:
{% raw %}<pre>\[K\models\text{grandsonOf(Peter, Joseph)}\]</pre>{% endraw %}

## Knowledge Graphs

Binary predicates allow us to talk about graphs.

Let {% raw %}<pre>\(K_r\)</pre>{% endraw %} contain:

* {% raw %}<pre>\(\text{sonOf}(x,y)\rightarrow\text{descendantOf}(x,y)\)</pre>{% endraw %}
* {% raw %}<pre>\(\text{sonOf}(x,y)\wedge\text{descendantOf}(y,z)\rightarrow\text{descendantOf}(x,z)\)</pre>{% endraw %}

Let {% raw %}<pre>\(K_A\)</pre>{% endraw %} be {% raw %}<pre>\(\{\text{sonOf(Peter, John), sonOf(John, Joseph)}\}\)</pre>{% endraw %}

{% raw %}<pre>\(K_a\)</pre>{% endraw %} can be seen as the following graph  (individual names = nodes, relations = edges):

```mermaid
graph LR
Peter -->|sonOf| John
Peter -->|descendantOf| John
John -->|sonOf| Joseph
John -->|descendantOf| Joseph
Peter -->|descendantOf| Joseph

```
*Labeled Graph.*

Computing {% raw %}<pre>\(\text{DerivedAssertions}\)</pre>{% endraw %} corresponds to graph completion.

### Example

Let {% raw %}<pre>\(K_r\)</pre>{% endraw %} contain:

* {% raw %}<pre>\(\text{childOf}(x,y)\wedge\text{childOf}(z,y)\rightarrow\text{siblingOf}(x,z)\)</pre>{% endraw %}
* {% raw %}<pre>\(\text{Female}(x)\wedge\text{siblingOf}(x,y)\rightarrow\text{sisterOf}(x,y)\)</pre>{% endraw %}
* {% raw %}<pre>\(\text{Male}(x)\wedge\text{siblingOf}(x,y)\rightarrow\text{brotherOf}(x,y)\)</pre>{% endraw %}

Let {% raw %}<pre>\(K_a\)</pre>{% endraw %} be:
{% raw %}<pre>\[\{\text{Female(Alice),Male(Bob),childOf(Alice,Carl),childOf(Bob,Carl)}\}\]</pre>{% endraw %}

```mermaid
graph LR
subgraph Female
Alice
end
subgraph Male
Bob
end
Alice ---|siblingOf| Bob
Alice -->|sisterOf| Bob
Bob -->|brotherOf| Alice
Alice -->|childOf| Carl
Bob -->|childOf| Carl
```

We assume different variable are replace by different individuals. This statement means that people can't be their own siblings.



