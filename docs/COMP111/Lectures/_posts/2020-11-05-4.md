---
title: COMP111 - Relations & Non-Unary Rule-Based Systems
tags: COMP111 Lectures
---
You cannot express relations between objects using the concepts we have learned so far. **Relations** are expressed as such: 

* A **relation name** {% raw %}\(R\){% endraw %} denotes a set of **pairs** of individual object. Relation names are also called **binary predicates**: 
	* {% raw %}\(\text{sonOf}\){% endraw %}
	* {% raw %}\(\text{grandsonOf}\){% endraw %}
	* These call also be denotes by upper case letters {% raw %}\(R,S,R_1,R_2\){% endraw %} and so on.
	
To express that an individual object {% raw %}\(a\){% endraw %} is in the relation {% raw %}\(R\){% endraw %} to an individual object {% raw %}\(b\){% endraw %} we write {% raw %}\(R(a,b)\){% endraw %}. {% raw %}\(R(a,b)\){% endraw %} is *also* called an **atomic assertion**. This can also be read as {% raw %}\(a\){% endraw %} is in relation {% raw %}\(R\){% endraw %} to {% raw %}\(b\){% endraw %}:

* {% raw %}\(\text{sonOf(Peter, John)}\){% endraw %}, where {% raw %}\(\text{Peter}\){% endraw %} is the son of {% raw %}\(\text{John}\){% endraw %}.

## Rule-Based Systems
A rule has the form:
{% raw %}\]{% endraw %}R_1(x_1,y_1)\wedge\ldots\wedge R_n(x_n,y_n)\wedge A_1(x_{n+1})\wedge\ldots\wedge A_m(x_{n+m})\rightarrow R(x,y)\]
or
{% raw %}\]{% endraw %}R_1(x_1,y_1)\wedge\ldots\wedge R_n(x_n,y_n)\wedge A_1(x_{n+1})\wedge\ldots\wedge A_m(x_{n+m})\rightarrow A(x)\]
Where:

* {% raw %}\(R_1,\ldots,R_n\){% endraw %} and {% raw %}\(R\){% endraw %} are relation names.
* {% raw %}\(A_1,\ldots,A_n\){% endraw %} and {% raw %}\(A\){% endraw %} are class names.
* {% raw %}\(x_1,y_1,\ldots,x_n,y_n,x_{n+1},\ldots,x_{n+m},x,y\){% endraw %} are individual variables.

A rule-based knowledge base {% raw %}\(K\){% endraw %} is a collection {% raw %}\(K_a\){% endraw %} of atomic assertions and {% raw %}\(K_r\){% endraw %} of rules.

### Example

Consider the following set {% raw %}\(K_a\){% endraw %} of atomic assertions:

* {% raw %}\(\text{sonOf(Peter, John)}\){% endraw %}
* {% raw %}\(\text{sonOf(John, Joseph)}\){% endraw %}

Consider the following set {% raw %}\(K_r\){% endraw %} of rules:

* {% raw %}\(\text{sonOf}(x,y)\wedge\text{sonOf}(y,z)\rightarrow\text{grandsonOf}(x,z)\){% endraw %}

Then {% raw %}\(\text{grandsonOf(Peter, Joseph)}\){% endraw %} follows from {% raw %}\(K\){% endraw %}, in symbols:
{% raw %}\]{% endraw %}K\models\text{grandsonOf(Peter, Joseph)}\]

## Knowledge Graphs

Binary predicates allow us to talk about graphs.

Let {% raw %}\(K_r\){% endraw %} contain:

* {% raw %}\(\text{sonOf}(x,y)\rightarrow\text{descendantOf}(x,y)\){% endraw %}
* {% raw %}\(\text{sonOf}(x,y)\wedge\text{descendantOf}(y,z)\rightarrow\text{descendantOf}(x,z)\){% endraw %}

Let {% raw %}\(K_A\){% endraw %} be {% raw %}\(\{\text{sonOf(Peter, John), sonOf(John, Joseph)}\}\){% endraw %}

{% raw %}\(K_a\){% endraw %} can be seen as the following graph  (individual names = nodes, relations = edges):

```mermaid
graph LR
Peter -->|sonOf| John
Peter -->|descendantOf| John
John -->|sonOf| Joseph
John -->|descendantOf| Joseph
Peter -->|descendantOf| Joseph

```
*Labeled Graph.*

Computing {% raw %}\(\text{DerivedAssertions}\){% endraw %} corresponds to graph completion.

### Example

Let {% raw %}\(K_r\){% endraw %} contain:

* {% raw %}\(\text{childOf}(x,y)\wedge\text{childOf}(z,y)\rightarrow\text{siblingOf}(x,z)\){% endraw %}
* {% raw %}\(\text{Female}(x)\wedge\text{siblingOf}(x,y)\rightarrow\text{sisterOf}(x,y)\){% endraw %}
* {% raw %}\(\text{Male}(x)\wedge\text{siblingOf}(x,y)\rightarrow\text{brotherOf}(x,y)\){% endraw %}

Let {% raw %}\(K_a\){% endraw %} be:
{% raw %}\]{% endraw %}\{\text{Female(Alice),Male(Bob),childOf(Alice,Carl),childOf(Bob,Carl)}\}\]

```mermaid
graph LR
subgraph Female
Alice
end
subgraph Male
Bob
end
Alice ---|siblingOf| Bob
Alice -->|sisterOf| Bob
Bob -->|brotherOf| Alice
Alice -->|childOf| Carl
Bob -->|childOf| Carl
```

We assume different variable are replace by different individuals. This statement means that people can't be their own siblings.



