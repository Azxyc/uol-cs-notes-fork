---
title: COMP111 - Relations & Non-Unary Rule-Based Systems
tags: COMP111 Lectures
---
You cannot express relations between objects using the concepts we have learned so far. **Relations** are expressed as such: 

* A **relation name** {% raw %}<![CDATA[\(R\)]]>{% endraw %} denotes a set of **pairs** of individual object. Relation names are also called **binary predicates**: 
	* {% raw %}<![CDATA[\(\text{sonOf}\)]]>{% endraw %}
	* {% raw %}<![CDATA[\(\text{grandsonOf}\)]]>{% endraw %}
	* These call also be denotes by upper case letters {% raw %}<![CDATA[\(R,S,R_1,R_2\)]]>{% endraw %} and so on.
	
To express that an individual object {% raw %}<![CDATA[\(a\)]]>{% endraw %} is in the relation {% raw %}<![CDATA[\(R\)]]>{% endraw %} to an individual object {% raw %}<![CDATA[\(b\)]]>{% endraw %} we write {% raw %}<![CDATA[\(R(a,b)\)]]>{% endraw %}. {% raw %}<![CDATA[\(R(a,b)\)]]>{% endraw %} is *also* called an **atomic assertion**. This can also be read as {% raw %}<![CDATA[\(a\)]]>{% endraw %} is in relation {% raw %}<![CDATA[\(R\)]]>{% endraw %} to {% raw %}<![CDATA[\(b\)]]>{% endraw %}:

* {% raw %}<![CDATA[\(\text{sonOf(Peter, John)}\)]]>{% endraw %}, where {% raw %}<![CDATA[\(\text{Peter}\)]]>{% endraw %} is the son of {% raw %}<![CDATA[\(\text{John}\)]]>{% endraw %}.

## Rule-Based Systems
A rule has the form:
{% raw %}<![CDATA[\[R_1(x_1,y_1)\wedge\ldots\wedge R_n(x_n,y_n)\wedge A_1(x_{n+1})\wedge\ldots\wedge A_m(x_{n+m})\rightarrow R(x,y)\]]]>{% endraw %}
or
{% raw %}<![CDATA[\[R_1(x_1,y_1)\wedge\ldots\wedge R_n(x_n,y_n)\wedge A_1(x_{n+1})\wedge\ldots\wedge A_m(x_{n+m})\rightarrow A(x)\]]]>{% endraw %}
Where:

* {% raw %}<![CDATA[\(R_1,\ldots,R_n\)]]>{% endraw %} and {% raw %}<![CDATA[\(R\)]]>{% endraw %} are relation names.
* {% raw %}<![CDATA[\(A_1,\ldots,A_n\)]]>{% endraw %} and {% raw %}<![CDATA[\(A\)]]>{% endraw %} are class names.
* {% raw %}<![CDATA[\(x_1,y_1,\ldots,x_n,y_n,x_{n+1},\ldots,x_{n+m},x,y\)]]>{% endraw %} are individual variables.

A rule-based knowledge base {% raw %}<![CDATA[\(K\)]]>{% endraw %} is a collection {% raw %}<![CDATA[\(K_a\)]]>{% endraw %} of atomic assertions and {% raw %}<![CDATA[\(K_r\)]]>{% endraw %} of rules.

### Example

Consider the following set {% raw %}<![CDATA[\(K_a\)]]>{% endraw %} of atomic assertions:

* {% raw %}<![CDATA[\(\text{sonOf(Peter, John)}\)]]>{% endraw %}
* {% raw %}<![CDATA[\(\text{sonOf(John, Joseph)}\)]]>{% endraw %}

Consider the following set {% raw %}<![CDATA[\(K_r\)]]>{% endraw %} of rules:

* {% raw %}<![CDATA[\(\text{sonOf}(x,y)\wedge\text{sonOf}(y,z)\rightarrow\text{grandsonOf}(x,z)\)]]>{% endraw %}

Then {% raw %}<![CDATA[\(\text{grandsonOf(Peter, Joseph)}\)]]>{% endraw %} follows from {% raw %}<![CDATA[\(K\)]]>{% endraw %}, in symbols:
{% raw %}<![CDATA[\[K\models\text{grandsonOf(Peter, Joseph)}\]]]>{% endraw %}

## Knowledge Graphs

Binary predicates allow us to talk about graphs.

Let {% raw %}<![CDATA[\(K_r\)]]>{% endraw %} contain:

* {% raw %}<![CDATA[\(\text{sonOf}(x,y)\rightarrow\text{descendantOf}(x,y)\)]]>{% endraw %}
* {% raw %}<![CDATA[\(\text{sonOf}(x,y)\wedge\text{descendantOf}(y,z)\rightarrow\text{descendantOf}(x,z)\)]]>{% endraw %}

Let {% raw %}<![CDATA[\(K_A\)]]>{% endraw %} be {% raw %}<![CDATA[\(\{\text{sonOf(Peter, John), sonOf(John, Joseph)}\}\)]]>{% endraw %}

{% raw %}<![CDATA[\(K_a\)]]>{% endraw %} can be seen as the following graph  (individual names = nodes, relations = edges):

```mermaid
graph LR
Peter -->|sonOf| John
Peter -->|descendantOf| John
John -->|sonOf| Joseph
John -->|descendantOf| Joseph
Peter -->|descendantOf| Joseph

```
*Labeled Graph.*

Computing {% raw %}<![CDATA[\(\text{DerivedAssertions}\)]]>{% endraw %} corresponds to graph completion.

### Example

Let {% raw %}<![CDATA[\(K_r\)]]>{% endraw %} contain:

* {% raw %}<![CDATA[\(\text{childOf}(x,y)\wedge\text{childOf}(z,y)\rightarrow\text{siblingOf}(x,z)\)]]>{% endraw %}
* {% raw %}<![CDATA[\(\text{Female}(x)\wedge\text{siblingOf}(x,y)\rightarrow\text{sisterOf}(x,y)\)]]>{% endraw %}
* {% raw %}<![CDATA[\(\text{Male}(x)\wedge\text{siblingOf}(x,y)\rightarrow\text{brotherOf}(x,y)\)]]>{% endraw %}

Let {% raw %}<![CDATA[\(K_a\)]]>{% endraw %} be:
{% raw %}<![CDATA[\[\{\text{Female(Alice),Male(Bob),childOf(Alice,Carl),childOf(Bob,Carl)}\}\]]]>{% endraw %}

```mermaid
graph LR
subgraph Female
Alice
end
subgraph Male
Bob
end
Alice ---|siblingOf| Bob
Alice -->|sisterOf| Bob
Bob -->|brotherOf| Alice
Alice -->|childOf| Carl
Bob -->|childOf| Carl
```

We assume different variable are replace by different individuals. This statement means that people can't be their own siblings.



