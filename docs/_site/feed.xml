<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/UoL/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/UoL/" rel="alternate" type="text/html" /><updated>2020-12-02T15:58:06+00:00</updated><id>http://localhost:4000/UoL/feed.xml</id><title type="html">Uni Notes</title><subtitle>A site containing my notes for all my modules taken at the University of Liverpool.
</subtitle><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><entry><title type="html">COMP107 - Assessment 2 - Meeting 1</title><link href="http://localhost:4000/UoL/comp107/assessments/2020/12/02/1.html" rel="alternate" type="text/html" title="COMP107 - Assessment 2 - Meeting 1" /><published>2020-12-02T00:00:00+00:00</published><updated>2020-12-02T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp107/assessments/2020/12/02/1</id><content type="html" xml:base="http://localhost:4000/UoL/comp107/assessments/2020/12/02/1.html">&lt;h2 id=&quot;role-call&quot;&gt;Role Call&lt;/h2&gt;
&lt;p&gt;Liam, Ravi and Ben Weston were present.&lt;/p&gt;

&lt;h2 id=&quot;identifying-submission-requirements&quot;&gt;Identifying Submission Requirements&lt;/h2&gt;
&lt;p&gt;We had a look at the marking criteria to identify the requirements for the report.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Identify at least three users or view which provide three different perspectives on the model?&lt;/li&gt;
  &lt;li&gt;For the user preservatives create 4 - 5 different user stories.&lt;/li&gt;
  &lt;li&gt;Group them in a number of iterations.&lt;/li&gt;
  &lt;li&gt;Draw out the user stories in an EER diagram. Over various iterations.
    &lt;ul&gt;
      &lt;li&gt;Draw EER diagram for each user story.&lt;/li&gt;
      &lt;li&gt;Merge those together into user perspectives&lt;/li&gt;
      &lt;li&gt;Merge those together into one EER diagram for the butler.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Make sure to include all EER diagram features in our diagrams to make them as complete as possible.&lt;/p&gt;

    &lt;p class=&quot;warning&quot;&gt;Find out about tableaux testing to check if your design produces spurious records.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Additionally there should be descriptions that tie the EER diagrams together.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;method-of-collaboration&quot;&gt;Method of Collaboration&lt;/h2&gt;
&lt;p&gt;We should collaborate in a collaborative word document. The link will be in the chat and I will put it &lt;a href=&quot;https://theuniversityofliverpool-my.sharepoint.com/:w:/g/personal/pslrimme_liverpool_ac_uk/EeQ192A2au5BiL3bXaAfThYBg70DZD49EASdD04O2dLZYQ?e=yVUTC8&quot;&gt;here&lt;/a&gt; too.&lt;/p&gt;

&lt;p&gt;We should base our document on the following &lt;a href=&quot;https://liverpool.instructure.com/courses/17251/files/1391047/download?wrap=1&quot;&gt;template&lt;/a&gt;.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;The slides for the assignment are &lt;a href=&quot;https://liverpool.instructure.com/courses/17251/files/1390327/download?wrap=1&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP107" /><category term="Assessments" /><category term="COMP107" /><category term="Meetings" /><summary type="html">Role Call Liam, Ravi and Ben Weston were present. Identifying Submission Requirements We had a look at the marking criteria to identify the requirements for the report. Identify at least three users or view which provide three different perspectives on the model? For the user preservatives create 4 - 5 different user stories. Group them in a number of iterations. Draw out the user stories in an EER diagram. Over various iterations. Draw EER diagram for each user story. Merge those together into user perspectives Merge those together into one EER diagram for the butler. Make sure to include all EER diagram features in our diagrams to make them as complete as possible. Find out about tableaux testing to check if your design produces spurious records. Additionally there should be descriptions that tie the EER diagrams together. Method of Collaboration We should collaborate in a collaborative word document. The link will be in the chat and I will put it here too. We should base our document on the following template. The slides for the assignment are here.</summary></entry><entry><title type="html">COMP109 - Logic - 3</title><link href="http://localhost:4000/UoL/comp109/lectures/2020/12/02/1.html" rel="alternate" type="text/html" title="COMP109 - Logic - 3" /><published>2020-12-02T00:00:00+00:00</published><updated>2020-12-02T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp109/lectures/2020/12/02/1</id><content type="html" xml:base="http://localhost:4000/UoL/comp109/lectures/2020/12/02/1.html">&lt;h2 id=&quot;semantic-consequence&quot;&gt;Semantic Consequence&lt;/h2&gt;
&lt;p&gt;Suppose \(\Gamma\) is a finite set of formulas and \(P\) is a formula. Then \(P\) follows from \(\Gamma\) (is a semantic consequence of \(\Gamma\)) if the following implication holds for every interpretation \(I\):&lt;/p&gt;

&lt;p&gt;\[\text{If } I(Q)=1\text{ for all } Q\in \Gamma,\text{then } I(P)=1\]&lt;/p&gt;

&lt;p&gt;This is denoted by:&lt;/p&gt;

&lt;p&gt;\[\Gamma \models P\]&lt;/p&gt;

&lt;h3 id=&quot;logical-puzzles&quot;&gt;Logical Puzzles&lt;/h3&gt;
&lt;p&gt;An island has two kinds of inhabitants, knights, who always tell the truth, and knaves, who always lie.&lt;/p&gt;

&lt;p&gt;You go to the island and meet \(A\) and \(B\).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(A\) says, “\(B\) is a knight.”&lt;/li&gt;
  &lt;li&gt;\(B\) says, “The two of us are opposite types.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What are \(A\) and \(B\)?&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;We can prove this in a proof by cases or, as the two people have a binary type you can model this question as below.&lt;/p&gt;

&lt;p&gt;\(p\): “\(A\) is a knight”; and \(q\): “\(B\) is a knight”&lt;/p&gt;

&lt;p&gt;Options for \(A\)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(p\) is true \(p\Rightarrow q\)&lt;/li&gt;
  &lt;li&gt;\(p\) is false \(\neg p\Rightarrow \neg q\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Options for \(B\)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(q\) is true \(q\Rightarrow \neg p\)&lt;/li&gt;
  &lt;li&gt;\(q\) is false \(\neg q\Rightarrow \neg p\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;info&quot;&gt;Here we are summarising the two statements as logical propositions.&lt;/p&gt;

&lt;h4 id=&quot;truth-table&quot;&gt;Truth Table&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(p\)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(q\)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(\neg p\)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(\neg q\)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(p\Rightarrow q\)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(\neg p\Rightarrow \neg q\)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(q\Rightarrow \neg p\)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(\neg q\Rightarrow \neg p\)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;\(\wedge\)-ing together all the answers shows that the correct answer is \(p=0,q=0\). This means that \(A\) is a knave and \(B\) is a knave.&lt;/p&gt;

&lt;p&gt;Say that the implications in the truth table are numbered, \(\{1,2,3,4\}\). We can then rewrite this table as the following statement:&lt;/p&gt;

&lt;p&gt;\[\{1,2,3,4\}\models \neg p \wedge \neg q\]&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Show \(\{(p_1\wedge p_2)\}\models (p_1\vee p_2)\).&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;\(p_1\)&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;\(p_2\)&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;\((p_1\wedge p_2)\)&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;\((p_1\vee p_2)\)&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;The top line represents \((p_1\vee p_2)\) which we can see as \(p_1=1, p_2=1\). As the proposition and the result hold true in this case then the statement is correct.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Show \(\{p_1\}\not\models p_2\)&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;\(p_1\)&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;\(p_2\)&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;From this table we can see that the statement is correct as when \(p_1=1, p_2=0\).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;logic-and-proof-principles&quot;&gt;Logic and Proof Principles&lt;/h3&gt;
&lt;h4 id=&quot;modus-ponens&quot;&gt;&lt;em&gt;Modus Ponens&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;Direct proof corresponds to the following semantic consequence:&lt;/p&gt;

&lt;p&gt;\[\{P,(P\Rightarrow Q)\}\models Q\]&lt;/p&gt;

&lt;h4 id=&quot;reducto-ad-absurdum&quot;&gt;&lt;em&gt;Reducto ad Absurdum&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;Proof by contradiction corresponds to:&lt;/p&gt;

&lt;p&gt;\[\{(\neg P\Rightarrow\bot)\}\models P\]&lt;/p&gt;

&lt;p&gt;where \(\bot\) is a &lt;strong&gt;special proposition&lt;/strong&gt;, which is false under ever interpretation. \(\bot=a\wedge\neg a\).&lt;/p&gt;

&lt;h4 id=&quot;modus-tollens&quot;&gt;&lt;em&gt;Modus Tollens&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;Another look at proof by contradiction:&lt;/p&gt;

&lt;p&gt;\[\{(P\Rightarrow Q),\neg Q\}\models\neg P\]&lt;/p&gt;

&lt;h4 id=&quot;case-analysis&quot;&gt;Case Analysis&lt;/h4&gt;

&lt;p&gt;\[\{(P\Rightarrow Q),(R\Rightarrow Q),(P\vee R)\}\models Q\]&lt;/p&gt;

&lt;h2 id=&quot;proof-theory&quot;&gt;Proof Theory&lt;/h2&gt;

&lt;p&gt;We have studies proof as carefully reasoned arguments  to convince a sceptical listener that a given statement is true. These are called &lt;strong&gt;social proofs&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Proof theory&lt;/strong&gt; is a branch of mathematical logic dealing with proofs as a mathematical objects:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Strings of symbols.&lt;/li&gt;
  &lt;li&gt;Rules for manipulation.&lt;/li&gt;
  &lt;li&gt;Mathematics becomes a game played with strings of symbols.&lt;/li&gt;
  &lt;li&gt;Can be read and interpreted by computers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is to say that in prof theory we make statements that computers are able to solve by putting them in a very structured language. This language can then be solved by Boolean logic.&lt;/p&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP109" /><category term="Lectures" /><category term="COMP109" /><category term="Lectures" /><summary type="html">Semantic Consequence Suppose \(\Gamma\) is a finite set of formulas and \(P\) is a formula. Then \(P\) follows from \(\Gamma\) (is a semantic consequence of \(\Gamma\)) if the following implication holds for every interpretation \(I\): \[\text{If } I(Q)=1\text{ for all } Q\in \Gamma,\text{then } I(P)=1\] This is denoted by: \[\Gamma \models P\] Logical Puzzles An island has two kinds of inhabitants, knights, who always tell the truth, and knaves, who always lie. You go to the island and meet \(A\) and \(B\). \(A\) says, “\(B\) is a knight.” \(B\) says, “The two of us are opposite types.” What are \(A\) and \(B\)? We can prove this in a proof by cases or, as the two people have a binary type you can model this question as below. \(p\): “\(A\) is a knight”; and \(q\): “\(B\) is a knight” Options for \(A\) \(p\) is true \(p\Rightarrow q\) \(p\) is false \(\neg p\Rightarrow \neg q\) Options for \(B\) \(q\) is true \(q\Rightarrow \neg p\) \(q\) is false \(\neg q\Rightarrow \neg p\) Here we are summarising the two statements as logical propositions. Truth Table \(p\) \(q\) \(\neg p\) \(\neg q\) \(p\Rightarrow q\) \(\neg p\Rightarrow \neg q\) \(q\Rightarrow \neg p\) \(\neg q\Rightarrow \neg p\) 0 0 1 1 1 1 1 1 0 1 1 0 1 0 1 1 1 0 0 1 0 1 1 0 1 1 0 0 1 1 0 1 \(\wedge\)-ing together all the answers shows that the correct answer is \(p=0,q=0\). This means that \(A\) is a knave and \(B\) is a knave. Say that the implications in the truth table are numbered, \(\{1,2,3,4\}\). We can then rewrite this table as the following statement: \[\{1,2,3,4\}\models \neg p \wedge \neg q\] Examples Show \(\{(p_1\wedge p_2)\}\models (p_1\vee p_2)\). \(p_1\) \(p_2\) \((p_1\wedge p_2)\) \((p_1\vee p_2)\) 1 1 1 1 1 0 0 1 0 1 0 1 0 0 0 0 The top line represents \((p_1\vee p_2)\) which we can see as \(p_1=1, p_2=1\). As the proposition and the result hold true in this case then the statement is correct. Show \(\{p_1\}\not\models p_2\) \(p_1\) \(p_2\) 1 1 1 0 0 1 0 0 From this table we can see that the statement is correct as when \(p_1=1, p_2=0\). Logic and Proof Principles Modus Ponens Direct proof corresponds to the following semantic consequence: \[\{P,(P\Rightarrow Q)\}\models Q\] Reducto ad Absurdum Proof by contradiction corresponds to: \[\{(\neg P\Rightarrow\bot)\}\models P\] where \(\bot\) is a special proposition, which is false under ever interpretation. \(\bot=a\wedge\neg a\). Modus Tollens Another look at proof by contradiction: \[\{(P\Rightarrow Q),\neg Q\}\models\neg P\] Case Analysis \[\{(P\Rightarrow Q),(R\Rightarrow Q),(P\vee R)\}\models Q\] Proof Theory We have studies proof as carefully reasoned arguments to convince a sceptical listener that a given statement is true. These are called social proofs. Proof theory is a branch of mathematical logic dealing with proofs as a mathematical objects: Strings of symbols. Rules for manipulation. Mathematics becomes a game played with strings of symbols. Can be read and interpreted by computers. This is to say that in prof theory we make statements that computers are able to solve by putting them in a very structured language. This language can then be solved by Boolean logic.</summary></entry><entry><title type="html">COMP105 - Lecture 23-1</title><link href="http://localhost:4000/UoL/comp105/lectures/2020/12/01/1.html" rel="alternate" type="text/html" title="COMP105 - Lecture 23-1" /><published>2020-12-01T00:00:00+00:00</published><updated>2020-12-01T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp105/lectures/2020/12/01/1</id><content type="html" xml:base="http://localhost:4000/UoL/comp105/lectures/2020/12/01/1.html">&lt;p&gt;So far, we have studied pure functional programming. Pure functions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Have no side effects.&lt;/li&gt;
  &lt;li&gt;Always return a value.&lt;/li&gt;
  &lt;li&gt;Are deterministic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All &lt;strong&gt;computation&lt;/strong&gt; can be done in pure functional programming.&lt;/p&gt;

&lt;h2 id=&quot;io&quot;&gt;IO&lt;/h2&gt;
&lt;p&gt;Sometimes programs need to do non-pure things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Print something to the screen.&lt;/li&gt;
  &lt;li&gt;Read or write a file.&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;io-vs-pure-functional&quot;&gt;IO v.s. Pure Functional&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph LR
IO --&amp;gt; p[Pure Functional]
p --&amp;gt; IO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Impure IO code talks to the outside world.&lt;/li&gt;
  &lt;li&gt;Pure functional code does the interesting computation.&lt;/li&gt;
  &lt;li&gt;IO code can call pure functions; pure functions cannot call IO.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can call the “functions” that complete IO: IO actions. This is because they are not functions.&lt;/p&gt;

&lt;h3 id=&quot;getline&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getLine&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getLine&lt;/code&gt; read a line of input from the console.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;hello there&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;the-io-type&quot;&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; Type&lt;/h3&gt;
&lt;p&gt;This type marks a value as being impure.&lt;/p&gt;

&lt;p&gt;If a function returns an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type then it is impure:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It may have side effects.&lt;/li&gt;
  &lt;li&gt;It may return different values for the same inputs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type should be thought of as a box:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The box hold a value from an impure computation.&lt;/li&gt;
  &lt;li&gt;we can use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;-&lt;/code&gt; to get an impure value from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Hello&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Values must be unboxed before you use them in a pure function.&lt;/p&gt;

&lt;h3 id=&quot;getchar&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getChar&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;This function is similar to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getLine&lt;/code&gt; but returns a single &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Char&lt;/code&gt; instead of a string.&lt;/p&gt;

&lt;h3 id=&quot;putstrln&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;This IO action prints a string onto the console.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Hello&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There are no quotation marks as we are seeing this being written to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StdOut&lt;/code&gt; and not via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The unit type has the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type indicating that it has a side effect.&lt;/p&gt;

&lt;h3 id=&quot;the-unit-type&quot;&gt;The Unit Type&lt;/h3&gt;
&lt;p&gt;The unit type is a type represented by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;()&lt;/code&gt;. It only has one value which is itself.&lt;/p&gt;

&lt;p&gt;This is used to indicate that nothing interesting is returned. An example of this is with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt; where is doesn’t return a value but does have the side effect of printing to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StdOut&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;exercise&quot;&gt;Exercise&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;It will ask for two lines. It will then print out the two lines with a space between them back to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StdOut&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;It will read in a line with the expectation that there will be a number on it. It will then convert the line into an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; and print out the number &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+ 1&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Error due to mismatched types. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt; expects a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt; but an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type was given.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP105" /><category term="Lectures" /><category term="COMP105" /><category term="Lectures" /><summary type="html">So far, we have studied pure functional programming. Pure functions: Have no side effects. Always return a value. Are deterministic. All computation can be done in pure functional programming. IO Sometimes programs need to do non-pure things: Print something to the screen. Read or write a file. … IO v.s. Pure Functional graph LR IO --&amp;gt; p[Pure Functional] p --&amp;gt; IO Impure IO code talks to the outside world. Pure functional code does the interesting computation. IO code can call pure functions; pure functions cannot call IO. We can call the “functions” that complete IO: IO actions. This is because they are not functions. getLine getLine read a line of input from the console. &amp;gt; getLine hello there &quot;hello there&quot; &amp;gt; :t getLine getLine :: IO String The IO Type This type marks a value as being impure. If a function returns an IO type then it is impure: It may have side effects. It may return different values for the same inputs. The IO type should be thought of as a box: The box hold a value from an impure computation. we can use &amp;lt;- to get an impure value from the IO type. &amp;gt; x &amp;lt;- getLine Hello &amp;gt; x &quot;Hello&quot; Values must be unboxed before you use them in a pure function. getChar This function is similar to getLine but returns a single Char instead of a string. putStrLn This IO action prints a string onto the console. &amp;gt; putStrLn &quot;Hello&quot; Hello There are no quotation marks as we are seeing this being written to the StdOut and not via read. &amp;gt; :t putStrLn putStrLn :: String -&amp;gt; IO () The unit type has the IO type indicating that it has a side effect. The Unit Type The unit type is a type represented by (). It only has one value which is itself. This is used to indicate that nothing interesting is returned. An example of this is with putStrLn where is doesn’t return a value but does have the side effect of printing to the StdOut. Exercise It will ask for two lines. It will then print out the two lines with a space between them back to the StdOut. It will read in a line with the expectation that there will be a number on it. It will then convert the line into an Int and print out the number + 1. Error due to mismatched types. putStrLn expects a String but an IO type was given.</summary></entry><entry><title type="html">COMP105 - Lecture 23-2</title><link href="http://localhost:4000/UoL/comp105/lectures/2020/12/01/2.html" rel="alternate" type="text/html" title="COMP105 - Lecture 23-2" /><published>2020-12-01T00:00:00+00:00</published><updated>2020-12-01T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp105/lectures/2020/12/01/2</id><content type="html" xml:base="http://localhost:4000/UoL/comp105/lectures/2020/12/01/2.html">&lt;h2 id=&quot;writing-io-code&quot;&gt;Writing IO Code&lt;/h2&gt;
&lt;p&gt;We can write our own IO actions:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;print_two&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Print_two&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print_two&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;abc&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;def&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;abcdef&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note that the return type is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO ()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;combining-multiple-io-calls&quot;&gt;Combining Multiple IO Calls&lt;/h3&gt;
&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; syntax allows us to combine multiple IO actions.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;get_and_print&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;get_and_print&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This syntax allows us two write a sequence of statements that will be executed in order.&lt;/p&gt;

&lt;p&gt;You could also write this with the following syntax:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;get_and_print&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;get_and_print&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;the-do-syntax&quot;&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; Syntax&lt;/h4&gt;
&lt;p&gt;A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; block has the following syntax:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v1&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vk&lt;/code&gt; unbox the results of IO actions.&lt;/li&gt;
  &lt;li&gt;The final IO action is the return value.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v &amp;lt;-&lt;/code&gt; portion can be skipped if you are using an IO action purely for the side effect.&lt;/p&gt;

&lt;h4 id=&quot;let-in-do-blocks&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;let&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; Blocks&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;let&lt;/code&gt; expressions can be used inside &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; block in order to complete pure computations:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_one&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_one&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;info&quot;&gt;In a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; block you can type anything out that you would type into the command line of GHCI.&lt;/p&gt;

&lt;h4 id=&quot;if-in-do-blocks&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; Blocks&lt;/h4&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;guess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;guess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;42&quot;&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Correct!&quot;&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;You are very wrong.&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Both branches of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt; mut have the same type.&lt;/p&gt;

&lt;h3 id=&quot;do-blocks&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; Blocks&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; blocks let you sequence multiple actions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Works with IO actions.&lt;/li&gt;
  &lt;li&gt;Will not work in pure functional code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Functional programs consist of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A small amount of IO code.&lt;/li&gt;
  &lt;li&gt;A large amount of pure functional node.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;warning&quot;&gt;Don’t try to write your entire program in IO code.&lt;/p&gt;

&lt;h3 id=&quot;putting-values-in-the-io-box&quot;&gt;Putting Values in the IO Box&lt;/h3&gt;
&lt;p&gt;Sometimes we need to pus a pure value into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We can use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; function to do this.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;example&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;example&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You must use return to get the value out of an impure function.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;print_if_short&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_if_short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Both sides of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt; must have the type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO ()&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;So we use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return ()&lt;/code&gt; in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;else&lt;/code&gt; part.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;return&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;This function is not the same as in imperative languages &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; &lt;strong&gt;does not stop execution&lt;/strong&gt;. It just convert pure values to IO values.&lt;/p&gt;

&lt;h3 id=&quot;monad&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The type of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; mentions monads.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is because IO is a &lt;strong&gt;monad&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Whenever you see &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad m =&amp;gt;&lt;/code&gt; substitute &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;So &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return :: a -&amp;gt; IO a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You don’t need to know anything about monads for COMP105.&lt;/p&gt;

&lt;h2 id=&quot;exercises&quot;&gt;Exercises&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;doubleEcho&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;doubleEcho&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;firstWord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;firstWord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
     &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;[]&lt;/span&gt;
         &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;
         &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;printEven&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printEven&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;even&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
     &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;This doesn’t need to be done in a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; block as it is just one line.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP105" /><category term="Lectures" /><category term="COMP105" /><category term="Lectures" /><summary type="html">Writing IO Code We can write our own IO actions: print_two :: String -&amp;gt; String -&amp;gt; IO () Print_two s1 s2 = putStrLn (s1 ++ s2) &amp;gt; print_two &quot;abc&quot; &quot;def&quot; abcdef Note that the return type is IO (). Combining Multiple IO Calls The do syntax allows us to combine multiple IO actions. get_and_print :: IO () get_and_print = do x &amp;lt;- getLine y &amp;lt;- getLine putStrLn (x ++ &quot; &quot; ++ y) This syntax allows us two write a sequence of statements that will be executed in order. You could also write this with the following syntax: get_and_print :: IO () get_and_print = do x &amp;lt;- getLine y &amp;lt;- getLine putStrLn (x ++ &quot; &quot; ++ y) The do Syntax A do block has the following syntax: do v1 &amp;lt;- [IO action] v2 &amp;lt;- [IO action] ... vk &amp;lt;- [IO action] [IO action] v1 through vk unbox the results of IO actions. The final IO action is the return value. The v &amp;lt;- portion can be skipped if you are using an IO action purely for the side effect. let in do Blocks let expressions can be used inside do block in order to complete pure computations: add_one :: IO () add_one = do n &amp;lt;- getLine let num = (read n) :: Int out = show (num + 1) putStrLn out In a do block you can type anything out that you would type into the command line of GHCI. if in do Blocks guess :: IO () guess = do x &amp;lt;- getLine if x == &quot;42&quot; then putStrLn &quot;Correct!&quot; else putStrLn &quot;You are very wrong.&quot; Both branches of the if mut have the same type. do Blocks do blocks let you sequence multiple actions: Works with IO actions. Will not work in pure functional code. Functional programs consist of: A small amount of IO code. A large amount of pure functional node. Don’t try to write your entire program in IO code. Putting Values in the IO Box Sometimes we need to pus a pure value into IO. We can use the return function to do this. &amp;gt; :t &quot;hello&quot; &quot;hello&quot; :: [Char] &amp;gt; :t return &quot;hello&quot; IO [Char] example :: IO String example = do x &amp;lt;- getLine return (tail x) You must use return to get the value out of an impure function. print_if_short :: String -&amp;gt; IO () print_if_short str = if length str &amp;lt;= 2 then putStrLn str else return () Both sides of the if must have the type IO (): So we use return () in the else part. return This function is not the same as in imperative languages return does not stop execution. It just convert pure values to IO values. Monad The type of return mentions monads. &amp;gt; :t return return :: Monad m =&amp;gt; a -&amp;gt; m a This is because IO is a monad. Whenever you see Monad m =&amp;gt; substitute IO for m. So return :: a -&amp;gt; IO a You don’t need to know anything about monads for COMP105. Exercises doubleEcho :: IO () doubleEcho = do x &amp;lt;- getLine putStrLn x putStrLn x firstWord :: IO () firstWord = do string &amp;lt;- getLine if (words string) == [] then putStrLn &quot;&quot; else putStrLn (head . words $ string) printEven :: Int -&amp;gt; IO () printEven x = if (even x) then (putStrLn x) else return () This doesn’t need to be done in a do block as it is just one line.</summary></entry><entry><title type="html">COMP111 - Independent Random Variables</title><link href="http://localhost:4000/UoL/comp111/lectures/2020/12/01/1.html" rel="alternate" type="text/html" title="COMP111 - Independent Random Variables" /><published>2020-12-01T00:00:00+00:00</published><updated>2020-12-01T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp111/lectures/2020/12/01/1</id><content type="html" xml:base="http://localhost:4000/UoL/comp111/lectures/2020/12/01/1.html">&lt;p&gt;Random variables \(F\) and \(G\) are independent if:&lt;/p&gt;

&lt;p&gt;\[\mathbf{P}(F,G)=\mathbf{P}(F)\times\mathbf{P}(G)\]&lt;/p&gt;

&lt;p&gt;That is, for all values \(r\) and \(s\):&lt;/p&gt;

&lt;p&gt;\[P(F=r,G=s)=P(F=r)\times P(G=s)\]&lt;/p&gt;

&lt;p&gt;As one’s dental problems do not influence the weather, the pairs of random variables are each independent:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(\text{Toothache},\text{Weather}\)&lt;/li&gt;
  &lt;li&gt;\(\text{Catch},\text{Weather}\)&lt;/li&gt;
  &lt;li&gt;\(\text{Cavity},\text{Weather}\)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;example---weather-and-dental-problems&quot;&gt;Example - Weather and Dental Problems&lt;/h2&gt;
&lt;p&gt;The full joint probability distribution:&lt;/p&gt;

&lt;p&gt;\[\mathbf{P}(\text{Toothache, Catch, Cavity, Weather})\]&lt;/p&gt;

&lt;p&gt;has 32 entries. It contains four tables for the dentist variables and one for the four kinds of weather.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;The number of entries comes from the \(2\times2\times2\times4\) of the 2 outcomes for the 4 dentist variables and the 4 outcomes of the \(\text{Weather}\) variable.&lt;/p&gt;

&lt;p&gt;Thus we have:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;8 probabilities for \((\text{Weather}=\text{sunny})\):
    &lt;ul&gt;
      &lt;li&gt;\(P(\text{Weather}=\text{sunny}, \text{Toothache}=r_1, \text{Catch} =r_2,\text{Cavity}=r_3)\)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;And so on for the other three weather types.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Clearly we can make the independence assumption that for any combination of values of the random variables \(\text{Toothache, Catch, Cavity,}\) the probability for \(\text{Weather}\). For example:&lt;/p&gt;

&lt;p&gt;\[
\begin{aligned}
&amp;amp; P(\text{Weather}=\text{sunny} \vert \text{Toothache}=r_1, \text{Catch} =r_2,\text{Cavity}=r_3)\\
=&amp;amp; P(\text{Weather}=\text{sunny})
\end{aligned}
\]&lt;/p&gt;

&lt;p&gt;for all \(r_1,r_2,r_3\in\{0,1\}\).&lt;/p&gt;

&lt;p&gt;Thus equivalently:&lt;/p&gt;

&lt;p&gt;\[
\begin{aligned}
&amp;amp; P(\text{Weather}=\text{sunny} \vert \text{Toothache}=r_1, \text{Catch} =r_2,\text{Cavity}=r_3)\\
=&amp;amp; P(\text{Weather}=\text{sunny})P(\text{Toothache}=r_1, \text{Catch} =r_2,\text{Cavity}=r_3)
\end{aligned}
\]&lt;/p&gt;

&lt;p&gt;for all \(r_1,r_2,r_3\in\{0,1\}\).&lt;/p&gt;

&lt;p&gt;This means that they are related proportionally.&lt;/p&gt;

&lt;p&gt;We have seen that the join probability distribution&lt;/p&gt;

&lt;p&gt;\[\mathbf{P}(\text{Weather, Toothache, Catch, Cavity})\]&lt;/p&gt;

&lt;p&gt;can be written as:&lt;/p&gt;

&lt;p&gt;\[\mathbf{P}(\text{Weather})\times\mathbf{P}(\text{Toothache, Catch, Cavity})\]&lt;/p&gt;

&lt;p&gt;The 32-element table for four variables can be constructed from one 4-element table and an 8-element table.&lt;/p&gt;

&lt;h2 id=&quot;independence-analysis&quot;&gt;Independence Analysis&lt;/h2&gt;
&lt;p&gt;Unfortunately this type of independence is very rare as generally things that you want to compare are inter-related. This is especially true within a single domain.
Conditional independence is much more prevalent and useful.&lt;/p&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP111" /><category term="Lectures" /><category term="COMP111" /><category term="Lectures" /><summary type="html">Random variables \(F\) and \(G\) are independent if: \[\mathbf{P}(F,G)=\mathbf{P}(F)\times\mathbf{P}(G)\] That is, for all values \(r\) and \(s\): \[P(F=r,G=s)=P(F=r)\times P(G=s)\] As one’s dental problems do not influence the weather, the pairs of random variables are each independent: \(\text{Toothache},\text{Weather}\) \(\text{Catch},\text{Weather}\) \(\text{Cavity},\text{Weather}\) Example - Weather and Dental Problems The full joint probability distribution: \[\mathbf{P}(\text{Toothache, Catch, Cavity, Weather})\] has 32 entries. It contains four tables for the dentist variables and one for the four kinds of weather. The number of entries comes from the \(2\times2\times2\times4\) of the 2 outcomes for the 4 dentist variables and the 4 outcomes of the \(\text{Weather}\) variable. Thus we have: 8 probabilities for \((\text{Weather}=\text{sunny})\): \(P(\text{Weather}=\text{sunny}, \text{Toothache}=r_1, \text{Catch} =r_2,\text{Cavity}=r_3)\) And so on for the other three weather types. Clearly we can make the independence assumption that for any combination of values of the random variables \(\text{Toothache, Catch, Cavity,}\) the probability for \(\text{Weather}\). For example: \[ \begin{aligned} &amp;amp; P(\text{Weather}=\text{sunny} \vert \text{Toothache}=r_1, \text{Catch} =r_2,\text{Cavity}=r_3)\\ =&amp;amp; P(\text{Weather}=\text{sunny}) \end{aligned} \] for all \(r_1,r_2,r_3\in\{0,1\}\). Thus equivalently: \[ \begin{aligned} &amp;amp; P(\text{Weather}=\text{sunny} \vert \text{Toothache}=r_1, \text{Catch} =r_2,\text{Cavity}=r_3)\\ =&amp;amp; P(\text{Weather}=\text{sunny})P(\text{Toothache}=r_1, \text{Catch} =r_2,\text{Cavity}=r_3) \end{aligned} \] for all \(r_1,r_2,r_3\in\{0,1\}\). This means that they are related proportionally. We have seen that the join probability distribution \[\mathbf{P}(\text{Weather, Toothache, Catch, Cavity})\] can be written as: \[\mathbf{P}(\text{Weather})\times\mathbf{P}(\text{Toothache, Catch, Cavity})\] The 32-element table for four variables can be constructed from one 4-element table and an 8-element table. Independence Analysis Unfortunately this type of independence is very rare as generally things that you want to compare are inter-related. This is especially true within a single domain. Conditional independence is much more prevalent and useful.</summary></entry><entry><title type="html">COMP105 - Lecture 22-1</title><link href="http://localhost:4000/UoL/comp105/lectures/2020/11/30/1.html" rel="alternate" type="text/html" title="COMP105 - Lecture 22-1" /><published>2020-11-30T00:00:00+00:00</published><updated>2020-11-30T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp105/lectures/2020/11/30/1</id><content type="html" xml:base="http://localhost:4000/UoL/comp105/lectures/2020/11/30/1.html">&lt;h2 id=&quot;recursive-types&quot;&gt;Recursive Types&lt;/h2&gt;

&lt;p&gt;We have seen types which contain other types. In a recursive custom type, some constructors contain the type itself.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IntList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IntList&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Some examples using this type:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- []&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- [1]&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- [1,2]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here is a more general list using a type variable:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is the same as the previous example but using any type (provided that it is the same type all the way through the list). To use this as an infix operator like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:&lt;/code&gt; you would do the following:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;functions-with-recursive-types&quot;&gt;Functions with Recursive Types&lt;/h3&gt;

&lt;p&gt;We can write functions for our custom list type:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;our_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;our_head&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Empty list&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;our_head&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This takes the first item in our custom list type and prints it.&lt;/p&gt;

&lt;p&gt;To get the tail you would use this function:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;our_tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;our_tail&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Empty list&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;our_tail&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;recursing-on-recursive-types&quot;&gt;Recursing on Recursive Types&lt;/h4&gt;

&lt;p&gt;We can also write recursive functions to process our recursive types. This is exactly the same as recusing on a list:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;our_sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;our_sum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt; 		&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;our_sum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;our_sum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;custom-lists&quot;&gt;Custom Lists&lt;/h3&gt;

&lt;p&gt;Here is a new list type that can contain two different types.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TwoList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TwoEmpty&lt;/span&gt;
				&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TwoList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BCons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TwoList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
					&lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is the type when making a list that contains a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Char&lt;/code&gt; and a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bool&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'a'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ACons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;BCons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TwoEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;TwoList&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;info&quot;&gt;This is not the same as a list with tuples as the next item in the list can be of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; or type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; not of both all the time. There is a cost also as you have to explicitly say if it is type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; or type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;exercises&quot;&gt;Exercises&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;ourElem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ourElem&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ourElem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; 	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherwise&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ourElem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;ourRange&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ourRange&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ourRange&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ourRange&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ThreeList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ThreeEmpty&lt;/span&gt;
                      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ThreeList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ThreeList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ThreeList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                      &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP105" /><category term="Lectures" /><category term="COMP105" /><category term="Lectures" /><summary type="html">Recursive Types We have seen types which contain other types. In a recursive custom type, some constructors contain the type itself. data IntList = Empty | Cons Int IntList deriving(Show) Some examples using this type: Empty -- [] Cons 1 (Empty) -- [1] Cons 1 (Cons 2 Empty) -- [1,2] Here is a more general list using a type variable: data List a = Empty | Cons a (List a) deriving(show) This is the same as the previous example but using any type (provided that it is the same type all the way through the list). To use this as an infix operator like : you would do the following: &amp;gt; 1 `Cons` (2 `Cons` Empty) Cons 1 (Cons 2 Empty) Functions with Recursive Types We can write functions for our custom list type: our_head :: List a -&amp;gt; a our_head Empty = error &quot;Empty list&quot; our_head (Cons x _) = x This takes the first item in our custom list type and prints it. To get the tail you would use this function: our_tail :: List a -&amp;gt; List a our_tail Empty = error &quot;Empty list&quot; our_tail (Cons _ x) = x Recursing on Recursive Types We can also write recursive functions to process our recursive types. This is exactly the same as recusing on a list: our_sum :: List Int -&amp;gt; Int our_sum Empty = 0 our_sum (Cons x xs) = x + our_sum xs Custom Lists Here is a new list type that can contain two different types. data TwoList a b = TwoEmpty | ACons a (TwoList a b) | BCons b (TwoList a b) deriving(show) This is the type when making a list that contains a Char and a Bool: &amp;gt; :t 'a' `ACons`(False `BCons` TwoEmpty) TwoList Char Bool This is not the same as a list with tuples as the next item in the list can be of type a or type b not of both all the time. There is a cost also as you have to explicitly say if it is type a or type b. Exercises ourElem :: Eq a =&amp;gt; List a -&amp;gt; a -&amp;gt; Bool ourElem Empty _ = False ourElem (List x xs) y | x == y = True | otherwise = ourElem xs ourRange :: Int -&amp;gt; List Int ourRange 0 = Empty ourRange x = Cons x (ourRange (x - 1)) data ThreeList a b c = ThreeEmpty | ACons a (ThreeList a b c) | ACons b (ThreeList a b c) | ACons c (ThreeList a b c) deriving(show)</summary></entry><entry><title type="html">COMP105 - Lecture 22-2</title><link href="http://localhost:4000/UoL/comp105/lectures/2020/11/30/2.html" rel="alternate" type="text/html" title="COMP105 - Lecture 22-2" /><published>2020-11-30T00:00:00+00:00</published><updated>2020-11-30T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp105/lectures/2020/11/30/2</id><content type="html" xml:base="http://localhost:4000/UoL/comp105/lectures/2020/11/30/2.html">&lt;h2 id=&quot;trees&quot;&gt;Trees&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
a[ ] --&amp;gt; b[ ]
a --&amp;gt; c[ ]
b --&amp;gt; d[ ]
b --&amp;gt; e[ ]
d --&amp;gt; f[ ]
d --&amp;gt; g[ ]
c --&amp;gt; h[ ]
c --&amp;gt; i[ ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A tree is composed of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Leaf nodes.
    &lt;ul&gt;
      &lt;li&gt;Leaves have no children.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Branch nodes.
    &lt;ul&gt;
      &lt;li&gt;Has a child which is a leaf.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;a-tree-type-in-haskell&quot;&gt;A Tree Type in Haskell&lt;/h3&gt;
&lt;p&gt;Any binary tree can be represented in this data type.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Tree&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Tree&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
a[ ] --&amp;gt; b[ ]
a --&amp;gt; c[ ]
c --&amp;gt; h[ ]
c --&amp;gt; i[ ]
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;recursion-on-trees&quot;&gt;Recursion on Trees&lt;/h3&gt;
&lt;p&gt;We can write recursive function that process tress.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Usually the recursive case will process both branches.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This function counts all the nodes in a tree:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;info&quot;&gt;For trees usually the base case is the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Leaf&lt;/code&gt; and the recursive rule operates on the two sub-trees of the branch node.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;trees-with-data&quot;&gt;Trees with Data&lt;/h2&gt;
&lt;p&gt;Nodes in a tree often hold data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
9 --&amp;gt; 4
4 --&amp;gt; 1
4 --&amp;gt; 6
1 --&amp;gt; 10 
1 --&amp;gt; 7
2 --&amp;gt; 3 
2 --&amp;gt; 0
9 --&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;type-of-trees-with-data&quot;&gt;Type of Trees with Data&lt;/h3&gt;
&lt;p&gt;This type allows each branch and leaf to have data of a single type associated with it:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
             &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
             &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
1 --&amp;gt; 7
7 --&amp;gt; 2 
7 --&amp;gt; 9
1 --&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;recursion-on-trees-with-data&quot;&gt;Recursion on Trees with Data&lt;/h3&gt;
&lt;p&gt;This function adds together the numbers from all the branches and leaves in a tree with data.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;tree_sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Num&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tree_sum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tree_sum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree_sum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree_sum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree_sum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;example---fibonacci-numbers&quot;&gt;Example - Fibonacci Numbers&lt;/h4&gt;
&lt;p&gt;Before we used this code to calculate the Fibonacci numbers. This is slow due to the large amount of branching:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
A[fib 4] --&amp;gt; B[fib 3]
A --&amp;gt; C[fib 2]
B --&amp;gt; D[fib 2]
B --&amp;gt; E[fib 1]
D --&amp;gt; F[fib 1]
D --&amp;gt; G[fib 0]
C --&amp;gt; H[fib 1]
C --&amp;gt; I[fib 0]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;how-many-recursive-calls-does-the-code-make&quot;&gt;How many recursive calls does the code make?&lt;/h5&gt;
&lt;p&gt;We can make a function to build the call tree.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Tree&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is the same structure  as the tree at the top of the example.&lt;/p&gt;

&lt;p&gt;To count the nodes in this tree we can use the function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size&lt;/code&gt; from earlier:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;fib_calls&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib_calls&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;177&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib_calls&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;21891&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib_calls&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2692537&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As we can see multiple recursion can be very slow if used incorrectly.&lt;/p&gt;

&lt;h4 id=&quot;example---finding-a-file&quot;&gt;Example - Finding a File&lt;/h4&gt;
&lt;p&gt;Suppose that we have a directory structure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
h[&quot;~/&quot;] --&amp;gt; d[docs/]
d --&amp;gt; a[a.txt]
d --&amp;gt; b[b.txt]
h --&amp;gt; c[c.txt]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Write a function that, given a filename, finds the path to that file.&lt;/p&gt;

&lt;p&gt;We can formulate the files as a data tree:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;~/&quot;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;docs/&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;a.txt&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;b.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;c.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;info&quot;&gt;This is the same as the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DTree&lt;/code&gt; above.&lt;/p&gt;

&lt;p&gt;Note that the file might not exist:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;So we will use the maybe type.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_file&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;a.txt&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;home/docs/a.txt&quot;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_file&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;d.txt&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;implementation&quot;&gt;Implementation&lt;/h5&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;find_file&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Dleaf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherwise&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;
    
&lt;span class=&quot;n&quot;&gt;find_file&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_file&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_file&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This implementation has two cases, one for the leaf and one for the branch.&lt;/p&gt;

&lt;h2 id=&quot;exercises&quot;&gt;Exercises&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;leafSum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DTree&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;leafSum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;leafSum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leafSum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leafSum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;treeElem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;treeElem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;treeElem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;treeElem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;treeElem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP105" /><category term="Lectures" /><category term="COMP105" /><category term="Lectures" /><summary type="html">Trees graph TD a[ ] --&amp;gt; b[ ] a --&amp;gt; c[ ] b --&amp;gt; d[ ] b --&amp;gt; e[ ] d --&amp;gt; f[ ] d --&amp;gt; g[ ] c --&amp;gt; h[ ] c --&amp;gt; i[ ] A tree is composed of: Leaf nodes. Leaves have no children. Branch nodes. Has a child which is a leaf. A Tree Type in Haskell Any binary tree can be represented in this data type. data Tree = Leaf | Branch Tree Tree deriving(Show) graph TD a[ ] --&amp;gt; b[ ] a --&amp;gt; c[ ] c --&amp;gt; h[ ] c --&amp;gt; i[ ] Branch Leaf (Branch Leaf Leaf) Recursion on Trees We can write recursive function that process tress. Usually the recursive case will process both branches. This function counts all the nodes in a tree: size :: Tree -&amp;gt; Int size (Leaf) = 1 size (Branch x y) = 1 +size x + size y For trees usually the base case is the Leaf and the recursive rule operates on the two sub-trees of the branch node. &amp;gt; size (Branch Leaf (Branch Leaf Leaf)) 5 Trees with Data Nodes in a tree often hold data. graph TD 9 --&amp;gt; 4 4 --&amp;gt; 1 4 --&amp;gt; 6 1 --&amp;gt; 10 1 --&amp;gt; 7 2 --&amp;gt; 3 2 --&amp;gt; 0 9 --&amp;gt; 2 Type of Trees with Data This type allows each branch and leaf to have data of a single type associated with it: data DTree a = DLeaf a | DBranch a (DTree a) (DTree a) deriving (Show) graph TD 1 --&amp;gt; 7 7 --&amp;gt; 2 7 --&amp;gt; 9 1 --&amp;gt; 4 DBranch 1 (DBranch 7 (DLeaf 2) (DLeaf 9)) (DLeaf 4) Recursion on Trees with Data This function adds together the numbers from all the branches and leaves in a tree with data. tree_sum :: Num a =&amp;gt; DTree a -&amp;gt; a tree_sum (DLeaf x) = x tree_sum (DBranch x 1 l) = x + tree_sum l + tree_sum r &amp;gt; tree_sum (DBranch 1 (DBranch 7 (DLeaf 2) (DLeaf 9)) (DLeaf 4)) 22 Example - Fibonacci Numbers Before we used this code to calculate the Fibonacci numbers. This is slow due to the large amount of branching: fib 0 = 0 fib 1 = 1 fib n = fib (n-1) + fib (n-2) graph TD A[fib 4] --&amp;gt; B[fib 3] A --&amp;gt; C[fib 2] B --&amp;gt; D[fib 2] B --&amp;gt; E[fib 1] D --&amp;gt; F[fib 1] D --&amp;gt; G[fib 0] C --&amp;gt; H[fib 1] C --&amp;gt; I[fib 0] How many recursive calls does the code make? We can make a function to build the call tree. fib_tree :: Int -&amp;gt; Tree fib_tree 0 = Leaf fib_tree 1 = Leaf fib_tree n = Branch (fib_tree (n-1)) (fib_tree (n-2)) &amp;gt; fib_tree 4 Branch (Branch (Branch Leaf Leaf) Leaf) (Branch Leaf Leaf) This is the same structure as the tree at the top of the example. To count the nodes in this tree we can use the function size from earlier: fib_calls n = size (fib_tree n) &amp;gt; fib_calls 10 177 &amp;gt; fib_calls 20 21891 &amp;gt;fib_calls 30 2692537 As we can see multiple recursion can be very slow if used incorrectly. Example - Finding a File Suppose that we have a directory structure: graph TD h[&quot;~/&quot;] --&amp;gt; d[docs/] d --&amp;gt; a[a.txt] d --&amp;gt; b[b.txt] h --&amp;gt; c[c.txt] Write a function that, given a filename, finds the path to that file. We can formulate the files as a data tree: let fs = DBranch &quot;~/&quot; (DBranch &quot;docs/&quot; (DLeaf &quot;a.txt&quot; ) (DLeaf &quot;b.txt&quot;)) (DLeaf &quot;c.txt&quot;) This is the same as the DTree above. Note that the file might not exist: So we will use the maybe type. &amp;gt; find_file &quot;a.txt&quot; fs Just &quot;home/docs/a.txt&quot; &amp;gt; find_file &quot;d.txt&quot; fs Nothing Implementation find_file file (Dleaf x) | x == file = Just file | otherwise = Nothing find_file file (DBranch x l r) = let left = find_file l right = find_file r in case (left, right) of (Just y, _) -&amp;gt; Just (x ++ y) (_, Just y) -&amp;gt; Just (x ++ y) (_, _) -&amp;gt; Nothing This implementation has two cases, one for the leaf and one for the branch. Exercises leafSum :: DTree Int -&amp;gt; Int leafSum (DLeaf x) = x leafSum (DBranch _ l r) = leafSum l + leafSum r treeElem :: Eq a =&amp;gt; a -&amp;gt; DTree a -&amp;gt; Bool treeElem x (DLeaf y) = x == y treeElem x (DBranch y l r) = (x == y) || treeElem x l || treeElem x r</summary></entry><entry><title type="html">COMP109 - Logic - 1</title><link href="http://localhost:4000/UoL/comp109/lectures/2020/11/30/1.html" rel="alternate" type="text/html" title="COMP109 - Logic - 1" /><published>2020-11-30T00:00:00+00:00</published><updated>2020-11-30T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp109/lectures/2020/11/30/1</id><content type="html" xml:base="http://localhost:4000/UoL/comp109/lectures/2020/11/30/1.html">&lt;p class=&quot;info&quot;&gt;This topic is very similar to the subjects covered in COMP111’s &lt;a href=&quot;/UoL/comp111/lectures/2020/11/12/1&quot;&gt;propositional logic&lt;/a&gt;. As result I will only be noting down significant differences.&lt;/p&gt;

&lt;p&gt;Logic is concerned with the truth a falsity of statements. The question is when does a statement follow from a set of statements.&lt;/p&gt;

&lt;h2 id=&quot;propositional-logic&quot;&gt;Propositional Logic&lt;/h2&gt;
&lt;p&gt;Propositional logic is logic which only concerns itself with whether something is true or false. Other languages differ themselves as they deal with uncertainties.&lt;/p&gt;

&lt;p&gt;A proposition is a statement that can either be true or false. A statement like \(4+5\) is not a proposition as it doesn’t give a true or false answer.&lt;/p&gt;

&lt;h3 id=&quot;compound-propositions&quot;&gt;Compound Propositions&lt;/h3&gt;
&lt;p&gt;More complex propositions are formed using logical connectives (also called Boolean connectives).&lt;/p&gt;

&lt;p&gt;The basic connectives are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;\(\neg\): Negation (read “not”).&lt;/li&gt;
  &lt;li&gt;\(\wedge\): Conjunction (read “and”).&lt;/li&gt;
  &lt;li&gt;\(\vee\): Disjunction (read “or”).
    &lt;ul&gt;
      &lt;li&gt;These are the scientific names and they make a difference between the english and mathematical words.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;\(\Rightarrow\): Implication (read “if…then”).
    &lt;ul&gt;
      &lt;li&gt;In other schools this may be written as \(\rightarrow\) or as \(\subseteq\).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;\(\Leftrightarrow\): Equivalence (read “if, and only if,”).
    &lt;ul&gt;
      &lt;li&gt;Similar to 4. the notation is not as set as 1,2 and 3. This may be written as \(\leftrightarrow\) or \(\equiv\).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Propositional formed using these logical connectives are called compound propositions; otherwise atomic propositions.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A propositional formula is either an atom ic or compound proposition.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP109" /><category term="Lectures" /><category term="COMP109" /><category term="Lectures" /><summary type="html">This topic is very similar to the subjects covered in COMP111’s propositional logic. As result I will only be noting down significant differences. Logic is concerned with the truth a falsity of statements. The question is when does a statement follow from a set of statements. Propositional Logic Propositional logic is logic which only concerns itself with whether something is true or false. Other languages differ themselves as they deal with uncertainties. A proposition is a statement that can either be true or false. A statement like \(4+5\) is not a proposition as it doesn’t give a true or false answer. Compound Propositions More complex propositions are formed using logical connectives (also called Boolean connectives). The basic connectives are: \(\neg\): Negation (read “not”). \(\wedge\): Conjunction (read “and”). \(\vee\): Disjunction (read “or”). These are the scientific names and they make a difference between the english and mathematical words. \(\Rightarrow\): Implication (read “if…then”). In other schools this may be written as \(\rightarrow\) or as \(\subseteq\). \(\Leftrightarrow\): Equivalence (read “if, and only if,”). Similar to 4. the notation is not as set as 1,2 and 3. This may be written as \(\leftrightarrow\) or \(\equiv\). Propositional formed using these logical connectives are called compound propositions; otherwise atomic propositions. A propositional formula is either an atom ic or compound proposition.</summary></entry><entry><title type="html">COMP109 - Logic - 2</title><link href="http://localhost:4000/UoL/comp109/lectures/2020/11/30/2.html" rel="alternate" type="text/html" title="COMP109 - Logic - 2" /><published>2020-11-30T00:00:00+00:00</published><updated>2020-11-30T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp109/lectures/2020/11/30/2</id><content type="html" xml:base="http://localhost:4000/UoL/comp109/lectures/2020/11/30/2.html">&lt;p class=&quot;info&quot;&gt;This lecture is very similar to COMP111’s &lt;a href=&quot;/UoL/comp111/lectures/2020/11/12/2&quot;&gt;truth values&lt;/a&gt; lecture. View that lecture for all truth tables.&lt;/p&gt;

&lt;h2 id=&quot;truth-values&quot;&gt;Truth Values&lt;/h2&gt;
&lt;p&gt;Interpretations are a way of assigning values to propositions which may vary depending on the situation or person who answers them.&lt;/p&gt;

&lt;p&gt;An interpretation \(I\) is a function which assigns to any atomic proposition \(p_i\) a truth value:&lt;/p&gt;

&lt;p&gt;\[I(p_i)\in \{0,1\}\]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If \(I(p_i)=1\), then \(p_i\) is called &lt;strong&gt;true&lt;/strong&gt; under the interpretation \(I\).&lt;/li&gt;
  &lt;li&gt;If \(I(p_i)=0\), then \(p_i\) is called &lt;strong&gt;false&lt;/strong&gt; under the interpretation \(I\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an assignment \(I\) we can compute the truth value of compute formulas step by step using so-called truth tables.&lt;/p&gt;

&lt;h3 id=&quot;implication&quot;&gt;Implication&lt;/h3&gt;

&lt;p&gt;The implication \((P\Rightarrow Q)\) of \(P\)  and \(Q\):
 \[\text{If } P \text{ then } Q\]&lt;/p&gt;

&lt;h4 id=&quot;truth-table&quot;&gt;Truth Table&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(P\)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(Q\)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\((P\Rightarrow Q)\)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Consider this table with the proposition \(P\) being a promise. If you don’t make a promise but you fulfil it anyway then you aren’t breaking that promise.&lt;/p&gt;

&lt;p&gt;Another example would be the following statement:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If a number is divisible by 6 then it is divisible by 3.
    &lt;ul&gt;
      &lt;li&gt;If it is not divisible by 6 but still divides by 3, this does not invalidate the proposition.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP109" /><category term="Lectures" /><category term="COMP109" /><category term="Lectures" /><summary type="html">This lecture is very similar to COMP111’s truth values lecture. View that lecture for all truth tables. Truth Values Interpretations are a way of assigning values to propositions which may vary depending on the situation or person who answers them. An interpretation \(I\) is a function which assigns to any atomic proposition \(p_i\) a truth value: \[I(p_i)\in \{0,1\}\] If \(I(p_i)=1\), then \(p_i\) is called true under the interpretation \(I\). If \(I(p_i)=0\), then \(p_i\) is called false under the interpretation \(I\). Given an assignment \(I\) we can compute the truth value of compute formulas step by step using so-called truth tables. Implication The implication \((P\Rightarrow Q)\) of \(P\) and \(Q\): \[\text{If } P \text{ then } Q\] Truth Table \(P\) \(Q\) \((P\Rightarrow Q)\) 1 1 1 1 0 0 0 1 1 0 0 1 Consider this table with the proposition \(P\) being a promise. If you don’t make a promise but you fulfil it anyway then you aren’t breaking that promise. Another example would be the following statement: If a number is divisible by 6 then it is divisible by 3. If it is not divisible by 6 but still divides by 3, this does not invalidate the proposition.</summary></entry><entry><title type="html">COMP107 - Tutorial 4</title><link href="http://localhost:4000/UoL/comp107/tutorials/2020/11/27/1.html" rel="alternate" type="text/html" title="COMP107 - Tutorial 4" /><published>2020-11-27T00:00:00+00:00</published><updated>2020-11-27T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp107/tutorials/2020/11/27/1</id><content type="html" xml:base="http://localhost:4000/UoL/comp107/tutorials/2020/11/27/1.html">&lt;h2 id=&quot;er-by-view-integration&quot;&gt;ER by View Integration&lt;/h2&gt;

&lt;p&gt;You should consider each user perspective separately.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Requirements are given for many users groups or applications independently.&lt;/li&gt;
  &lt;li&gt;an ER schema is designed  for each user group and application (typically by different developers.)&lt;/li&gt;
  &lt;li&gt;Individual views are merged into a global conceptual schema.&lt;/li&gt;
  &lt;li&gt;Individual views can be reconstructed as external schema after view integration.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;view-integration&quot;&gt;View Integration&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Identification of correspondences and conflicts among schema.
    &lt;ul&gt;
      &lt;li&gt;Need to identify constructs in schemas that represent the same real-world concept.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Modification of views to conform to one another.
    &lt;ul&gt;
      &lt;li&gt;Some of the view schemas may need to be refined to resolve conflicts identified in 1.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Merging of views.
    &lt;ul&gt;
      &lt;li&gt;Global schema is created by merging individual schemas.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Restructuring.
    &lt;ul&gt;
      &lt;li&gt;Global schema may require further refinement to remove redundancies or unnecessary complexity.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;example&quot;&gt;Example&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;In the example we put up all the diagrams next to each other to view the conflicts. They include:
    &lt;ul&gt;
      &lt;li&gt;Names (including synonyms).
        &lt;ul&gt;
          &lt;li&gt;Homonyms - Using the same name for different things.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Notions
        &lt;ul&gt;
          &lt;li&gt;Where concepts are represented as entities or attributes.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;From this you change each view individually to make them coherent with each other.&lt;/li&gt;
  &lt;li&gt;After this you eliminate redundancies to make them into a single diagram.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;task&quot;&gt;Task&lt;/h3&gt;
&lt;p&gt;Draw and ER or EER model to describe a library by using a view integration approach.&lt;/p&gt;

&lt;p&gt;The group made this in the first phase:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/UoL/assets/COMP107/Tutorials/2020-11-27-1-1.svg&quot; alt=&quot;1st Phase&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;warning&quot;&gt;We should stick very specifically to the story. Over-designing is bad for other people’s designs and you should stick to only the points in your story.&lt;/p&gt;

&lt;p class=&quot;error&quot;&gt;The subject of the user story &lt;strong&gt;does not&lt;/strong&gt; need to be included in the diagram. This is because they are the user and don’t need data stored about them to use the database.&lt;/p&gt;

&lt;p&gt;The group made this in the second phase.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/UoL/assets/COMP107/Tutorials/2020-11-27-1-2.svg&quot; alt=&quot;1st Phase&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;error&quot;&gt;Attributes should not be shared between different entities.&lt;/p&gt;

&lt;p class=&quot;error&quot;&gt;The attribute course should be an entity and not a complex attribute. This would make a student enrolled in many courses.&lt;/p&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP107" /><category term="Tutorials" /><category term="COMP107" /><category term="Tutorials" /><summary type="html">ER by View Integration You should consider each user perspective separately. Requirements are given for many users groups or applications independently. an ER schema is designed for each user group and application (typically by different developers.) Individual views are merged into a global conceptual schema. Individual views can be reconstructed as external schema after view integration. View Integration Identification of correspondences and conflicts among schema. Need to identify constructs in schemas that represent the same real-world concept. Modification of views to conform to one another. Some of the view schemas may need to be refined to resolve conflicts identified in 1. Merging of views. Global schema is created by merging individual schemas. Restructuring. Global schema may require further refinement to remove redundancies or unnecessary complexity. Example In the example we put up all the diagrams next to each other to view the conflicts. They include: Names (including synonyms). Homonyms - Using the same name for different things. Notions Where concepts are represented as entities or attributes. From this you change each view individually to make them coherent with each other. After this you eliminate redundancies to make them into a single diagram. Task Draw and ER or EER model to describe a library by using a view integration approach. The group made this in the first phase: We should stick very specifically to the story. Over-designing is bad for other people’s designs and you should stick to only the points in your story. The subject of the user story does not need to be included in the diagram. This is because they are the user and don’t need data stored about them to use the database. The group made this in the second phase. Attributes should not be shared between different entities. The attribute course should be an entity and not a complex attribute. This would make a student enrolled in many courses.</summary></entry></feed>