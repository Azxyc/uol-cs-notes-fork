<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/UoL/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/UoL/" rel="alternate" type="text/html" /><updated>2020-12-01T15:01:11+00:00</updated><id>http://localhost:4000/UoL/feed.xml</id><title type="html">Uni Notes</title><subtitle>A site containing my notes for all my modules taken at the University of Liverpool.
</subtitle><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><entry><title type="html">COMP105 - Lecture 23-1</title><link href="http://localhost:4000/UoL/comp105/lectures/2020/12/01/1.html" rel="alternate" type="text/html" title="COMP105 - Lecture 23-1" /><published>2020-12-01T00:00:00+00:00</published><updated>2020-12-01T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp105/lectures/2020/12/01/1</id><content type="html" xml:base="http://localhost:4000/UoL/comp105/lectures/2020/12/01/1.html">&lt;p&gt;So far, we have studied pure functional programming. Pure functions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Have no side effects.&lt;/li&gt;
  &lt;li&gt;Always return a value.&lt;/li&gt;
  &lt;li&gt;Are deterministic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All &lt;strong&gt;computation&lt;/strong&gt; can be done in pure functional programming.&lt;/p&gt;

&lt;h2 id=&quot;io&quot;&gt;IO&lt;/h2&gt;
&lt;p&gt;Sometimes programs need to do non-pure things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Print something to the screen.&lt;/li&gt;
  &lt;li&gt;Read or write a file.&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;io-vs-pure-functional&quot;&gt;IO v.s. Pure Functional&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph LR
IO --&amp;gt; p[Pure Functional]
p --&amp;gt; IO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Impure IO code talks to the outside world.&lt;/li&gt;
  &lt;li&gt;Pure functional code does the interesting computation.&lt;/li&gt;
  &lt;li&gt;IO code can call pure functions; pure functions cannot call IO.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can call the “functions” that complete IO: IO actions. This is because they are not functions.&lt;/p&gt;

&lt;h3 id=&quot;getline&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getLine&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getLine&lt;/code&gt; read a line of input from the console.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;hello there&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;the-io-type&quot;&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; Type&lt;/h3&gt;
&lt;p&gt;This type marks a value as being impure.&lt;/p&gt;

&lt;p&gt;If a function returns an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type then it is impure:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It may have side effects.&lt;/li&gt;
  &lt;li&gt;It may return different values for the same inputs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type should be thought of as a box:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The box hold a value from an impure computation.&lt;/li&gt;
  &lt;li&gt;we can use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;-&lt;/code&gt; to get an impure value from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Hello&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Values must be unboxed before you use them in a pure function.&lt;/p&gt;

&lt;h3 id=&quot;getchar&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getChar&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;This function is similar to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getLine&lt;/code&gt; but returns a single &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Char&lt;/code&gt; instead of a string.&lt;/p&gt;

&lt;h3 id=&quot;putstrln&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;This IO action prints a string onto the console.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Hello&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There are no quotation marks as we are seeing this being written to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StdOut&lt;/code&gt; and not via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The unit type has the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type indicating that it has a side effect.&lt;/p&gt;

&lt;h3 id=&quot;the-unit-type&quot;&gt;The Unit Type&lt;/h3&gt;
&lt;p&gt;The unit type is a type represented by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;()&lt;/code&gt;. It only has one value which is itself.&lt;/p&gt;

&lt;p&gt;This is used to indicate that nothing interesting is returned. An example of this is with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt; where is doesn’t return a value but does have the side effect of printing to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StdOut&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;exercise&quot;&gt;Exercise&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;It will ask for two lines. It will then print out the two lines with a space between them back to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StdOut&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;It will read in a line with the expectation that there will be a number on it. It will then convert the line into an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; and print out the number &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+ 1&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Error due to mismatched types. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;putStrLn&lt;/code&gt; expects a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt; but an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; type was given.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP105" /><category term="Lectures" /><category term="COMP105" /><category term="Lectures" /><summary type="html">So far, we have studied pure functional programming. Pure functions: Have no side effects. Always return a value. Are deterministic. All computation can be done in pure functional programming. IO Sometimes programs need to do non-pure things: Print something to the screen. Read or write a file. … IO v.s. Pure Functional graph LR IO --&amp;gt; p[Pure Functional] p --&amp;gt; IO Impure IO code talks to the outside world. Pure functional code does the interesting computation. IO code can call pure functions; pure functions cannot call IO. We can call the “functions” that complete IO: IO actions. This is because they are not functions. getLine getLine read a line of input from the console. &amp;gt; getLine hello there &quot;hello there&quot; &amp;gt; :t getLine getLine :: IO String The IO Type This type marks a value as being impure. If a function returns an IO type then it is impure: It may have side effects. It may return different values for the same inputs. The IO type should be thought of as a box: The box hold a value from an impure computation. we can use &amp;lt;- to get an impure value from the IO type. &amp;gt; x &amp;lt;- getLine Hello &amp;gt; x &quot;Hello&quot; Values must be unboxed before you use them in a pure function. getChar This function is similar to getLine but returns a single Char instead of a string. putStrLn This IO action prints a string onto the console. &amp;gt; putStrLn &quot;Hello&quot; Hello There are no quotation marks as we are seeing this being written to the StdOut and not via read. &amp;gt; :t putStrLn putStrLn :: String -&amp;gt; IO () The unit type has the IO type indicating that it has a side effect. The Unit Type The unit type is a type represented by (). It only has one value which is itself. This is used to indicate that nothing interesting is returned. An example of this is with putStrLn where is doesn’t return a value but does have the side effect of printing to the StdOut. Exercise It will ask for two lines. It will then print out the two lines with a space between them back to the StdOut. It will read in a line with the expectation that there will be a number on it. It will then convert the line into an Int and print out the number + 1. Error due to mismatched types. putStrLn expects a String but an IO type was given.</summary></entry><entry><title type="html">COMP105 - Lecture 23-2</title><link href="http://localhost:4000/UoL/comp105/lectures/2020/12/01/2.html" rel="alternate" type="text/html" title="COMP105 - Lecture 23-2" /><published>2020-12-01T00:00:00+00:00</published><updated>2020-12-01T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp105/lectures/2020/12/01/2</id><content type="html" xml:base="http://localhost:4000/UoL/comp105/lectures/2020/12/01/2.html">&lt;h2 id=&quot;writing-io-code&quot;&gt;Writing IO Code&lt;/h2&gt;
&lt;p&gt;We can write our own IO actions:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;print_two&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Print_two&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print_two&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;abc&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;def&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;abcdef&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note that the return type is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO ()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;combining-multiple-io-calls&quot;&gt;Combining Multiple IO Calls&lt;/h3&gt;
&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; syntax allows us to combine multiple IO actions.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;get_and_print&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;get_and_print&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This syntax allows us two write a sequence of statements that will be executed in order.&lt;/p&gt;

&lt;p&gt;You could also write this with the following syntax:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;get_and_print&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;get_and_print&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;the-do-syntax&quot;&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; Syntax&lt;/h4&gt;
&lt;p&gt;A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; block has the following syntax:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v1&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vk&lt;/code&gt; unbox the results of IO actions.&lt;/li&gt;
  &lt;li&gt;The final IO action is the return value.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v &amp;lt;-&lt;/code&gt; portion can be skipped if you are using an IO action purely for the side effect.&lt;/p&gt;

&lt;h4 id=&quot;let-in-do-blocks&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;let&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; Blocks&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;let&lt;/code&gt; expressions can be used inside &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; block in order to complete pure computations:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_one&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_one&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;info&quot;&gt;In a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; block you can type anything out that you would type into the command line of GHCI.&lt;/p&gt;

&lt;h4 id=&quot;if-in-do-blocks&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; Blocks&lt;/h4&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;guess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;guess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;42&quot;&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Correct!&quot;&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;You are very wrong.&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Both branches of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt; mut have the same type.&lt;/p&gt;

&lt;h3 id=&quot;do-blocks&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; Blocks&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; blocks let you sequence multiple actions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Works with IO actions.&lt;/li&gt;
  &lt;li&gt;Will not work in pure functional code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Functional programs consist of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A small amount of IO code.&lt;/li&gt;
  &lt;li&gt;A large amount of pure functional node.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;warning&quot;&gt;Don’t try to write your entire program in IO code.&lt;/p&gt;

&lt;h3 id=&quot;putting-values-in-the-io-box&quot;&gt;Putting Values in the IO Box&lt;/h3&gt;
&lt;p&gt;Sometimes we need to pus a pure value into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We can use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; function to do this.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;example&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;example&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You must use return to get the value out of an impure function.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;print_if_short&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_if_short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Both sides of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt; must have the type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO ()&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;So we use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return ()&lt;/code&gt; in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;else&lt;/code&gt; part.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;return&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;This function is not the same as in imperative languages &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; &lt;strong&gt;does not stop execution&lt;/strong&gt;. It just convert pure values to IO values.&lt;/p&gt;

&lt;h3 id=&quot;monad&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The type of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; mentions monads.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is because IO is a &lt;strong&gt;monad&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Whenever you see &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Monad m =&amp;gt;&lt;/code&gt; substitute &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO&lt;/code&gt; for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;So &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return :: a -&amp;gt; IO a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You don’t need to know anything about monads for COMP105.&lt;/p&gt;

&lt;h2 id=&quot;exercises&quot;&gt;Exercises&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;doubleEcho&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;doubleEcho&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;firstWord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;firstWord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt;
     &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;[]&lt;/span&gt;
         &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;
         &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;printEven&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printEven&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;even&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
     &lt;span class=&quot;kr&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;putStrLn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;kr&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;This doesn’t need to be done in a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; block as it is just one line.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP105" /><category term="Lectures" /><category term="COMP105" /><category term="Lectures" /><summary type="html">Writing IO Code We can write our own IO actions: print_two :: String -&amp;gt; String -&amp;gt; IO () Print_two s1 s2 = putStrLn (s1 ++ s2) &amp;gt; print_two &quot;abc&quot; &quot;def&quot; abcdef Note that the return type is IO (). Combining Multiple IO Calls The do syntax allows us to combine multiple IO actions. get_and_print :: IO () get_and_print = do x &amp;lt;- getLine y &amp;lt;- getLine putStrLn (x ++ &quot; &quot; ++ y) This syntax allows us two write a sequence of statements that will be executed in order. You could also write this with the following syntax: get_and_print :: IO () get_and_print = do x &amp;lt;- getLine y &amp;lt;- getLine putStrLn (x ++ &quot; &quot; ++ y) The do Syntax A do block has the following syntax: do v1 &amp;lt;- [IO action] v2 &amp;lt;- [IO action] ... vk &amp;lt;- [IO action] [IO action] v1 through vk unbox the results of IO actions. The final IO action is the return value. The v &amp;lt;- portion can be skipped if you are using an IO action purely for the side effect. let in do Blocks let expressions can be used inside do block in order to complete pure computations: add_one :: IO () add_one = do n &amp;lt;- getLine let num = (read n) :: Int out = show (num + 1) putStrLn out In a do block you can type anything out that you would type into the command line of GHCI. if in do Blocks guess :: IO () guess = do x &amp;lt;- getLine if x == &quot;42&quot; then putStrLn &quot;Correct!&quot; else putStrLn &quot;You are very wrong.&quot; Both branches of the if mut have the same type. do Blocks do blocks let you sequence multiple actions: Works with IO actions. Will not work in pure functional code. Functional programs consist of: A small amount of IO code. A large amount of pure functional node. Don’t try to write your entire program in IO code. Putting Values in the IO Box Sometimes we need to pus a pure value into IO. We can use the return function to do this. &amp;gt; :t &quot;hello&quot; &quot;hello&quot; :: [Char] &amp;gt; :t return &quot;hello&quot; IO [Char] example :: IO String example = do x &amp;lt;- getLine return (tail x) You must use return to get the value out of an impure function. print_if_short :: String -&amp;gt; IO () print_if_short str = if length str &amp;lt;= 2 then putStrLn str else return () Both sides of the if must have the type IO (): So we use return () in the else part. return This function is not the same as in imperative languages return does not stop execution. It just convert pure values to IO values. Monad The type of return mentions monads. &amp;gt; :t return return :: Monad m =&amp;gt; a -&amp;gt; m a This is because IO is a monad. Whenever you see Monad m =&amp;gt; substitute IO for m. So return :: a -&amp;gt; IO a You don’t need to know anything about monads for COMP105. Exercises doubleEcho :: IO () doubleEcho = do x &amp;lt;- getLine putStrLn x putStrLn x firstWord :: IO () firstWord = do string &amp;lt;- getLine if (words string) == [] then putStrLn &quot;&quot; else putStrLn (head . words $ string) printEven :: Int -&amp;gt; IO () printEven x = if (even x) then (putStrLn x) else return () This doesn’t need to be done in a do block as it is just one line.</summary></entry><entry><title type="html">COMP111 - Independent Random Variables</title><link href="http://localhost:4000/UoL/comp111/lectures/2020/12/01/1.html" rel="alternate" type="text/html" title="COMP111 - Independent Random Variables" /><published>2020-12-01T00:00:00+00:00</published><updated>2020-12-01T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp111/lectures/2020/12/01/1</id><content type="html" xml:base="http://localhost:4000/UoL/comp111/lectures/2020/12/01/1.html"></content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP111" /><category term="Lectures" /><category term="COMP111" /><category term="Lectures" /><summary type="html"></summary></entry><entry><title type="html">COMP105 - Lecture 22-1</title><link href="http://localhost:4000/UoL/comp105/lectures/2020/11/30/1.html" rel="alternate" type="text/html" title="COMP105 - Lecture 22-1" /><published>2020-11-30T00:00:00+00:00</published><updated>2020-11-30T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp105/lectures/2020/11/30/1</id><content type="html" xml:base="http://localhost:4000/UoL/comp105/lectures/2020/11/30/1.html">&lt;h2 id=&quot;recursive-types&quot;&gt;Recursive Types&lt;/h2&gt;

&lt;p&gt;We have seen types which contain other types. In a recursive custom type, some constructors contain the type itself.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IntList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IntList&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Some examples using this type:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- []&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- [1]&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- [1,2]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here is a more general list using a type variable:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is the same as the previous example but using any type (provided that it is the same type all the way through the list). To use this as an infix operator like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:&lt;/code&gt; you would do the following:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;functions-with-recursive-types&quot;&gt;Functions with Recursive Types&lt;/h3&gt;

&lt;p&gt;We can write functions for our custom list type:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;our_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;our_head&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Empty list&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;our_head&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This takes the first item in our custom list type and prints it.&lt;/p&gt;

&lt;p&gt;To get the tail you would use this function:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;our_tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;our_tail&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Empty list&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;our_tail&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;recursing-on-recursive-types&quot;&gt;Recursing on Recursive Types&lt;/h4&gt;

&lt;p&gt;We can also write recursive functions to process our recursive types. This is exactly the same as recusing on a list:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;our_sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;our_sum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt; 		&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;our_sum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;our_sum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;custom-lists&quot;&gt;Custom Lists&lt;/h3&gt;

&lt;p&gt;Here is a new list type that can contain two different types.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TwoList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TwoEmpty&lt;/span&gt;
				&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TwoList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;BCons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;TwoList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
					&lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is the type when making a list that contains a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Char&lt;/code&gt; and a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bool&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'a'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ACons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;BCons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;TwoEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;TwoList&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;info&quot;&gt;This is not the same as a list with tuples as the next item in the list can be of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; or type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; not of both all the time. There is a cost also as you have to explicitly say if it is type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; or type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;exercises&quot;&gt;Exercises&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;ourElem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ourElem&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;False&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ourElem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; 	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;True&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherwise&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ourElem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;ourRange&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ourRange&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Empty&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ourRange&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ourRange&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ThreeList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ThreeEmpty&lt;/span&gt;
                      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ThreeList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ThreeList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                      &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ThreeList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                      &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP105" /><category term="Lectures" /><category term="COMP105" /><category term="Lectures" /><summary type="html">Recursive Types We have seen types which contain other types. In a recursive custom type, some constructors contain the type itself. data IntList = Empty | Cons Int IntList deriving(Show) Some examples using this type: Empty -- [] Cons 1 (Empty) -- [1] Cons 1 (Cons 2 Empty) -- [1,2] Here is a more general list using a type variable: data List a = Empty | Cons a (List a) deriving(show) This is the same as the previous example but using any type (provided that it is the same type all the way through the list). To use this as an infix operator like : you would do the following: &amp;gt; 1 `Cons` (2 `Cons` Empty) Cons 1 (Cons 2 Empty) Functions with Recursive Types We can write functions for our custom list type: our_head :: List a -&amp;gt; a our_head Empty = error &quot;Empty list&quot; our_head (Cons x _) = x This takes the first item in our custom list type and prints it. To get the tail you would use this function: our_tail :: List a -&amp;gt; List a our_tail Empty = error &quot;Empty list&quot; our_tail (Cons _ x) = x Recursing on Recursive Types We can also write recursive functions to process our recursive types. This is exactly the same as recusing on a list: our_sum :: List Int -&amp;gt; Int our_sum Empty = 0 our_sum (Cons x xs) = x + our_sum xs Custom Lists Here is a new list type that can contain two different types. data TwoList a b = TwoEmpty | ACons a (TwoList a b) | BCons b (TwoList a b) deriving(show) This is the type when making a list that contains a Char and a Bool: &amp;gt; :t 'a' `ACons`(False `BCons` TwoEmpty) TwoList Char Bool This is not the same as a list with tuples as the next item in the list can be of type a or type b not of both all the time. There is a cost also as you have to explicitly say if it is type a or type b. Exercises ourElem :: Eq a =&amp;gt; List a -&amp;gt; a -&amp;gt; Bool ourElem Empty _ = False ourElem (List x xs) y | x == y = True | otherwise = ourElem xs ourRange :: Int -&amp;gt; List Int ourRange 0 = Empty ourRange x = Cons x (ourRange (x - 1)) data ThreeList a b c = ThreeEmpty | ACons a (ThreeList a b c) | ACons b (ThreeList a b c) | ACons c (ThreeList a b c) deriving(show)</summary></entry><entry><title type="html">COMP105 - Lecture 22-2</title><link href="http://localhost:4000/UoL/comp105/lectures/2020/11/30/2.html" rel="alternate" type="text/html" title="COMP105 - Lecture 22-2" /><published>2020-11-30T00:00:00+00:00</published><updated>2020-11-30T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp105/lectures/2020/11/30/2</id><content type="html" xml:base="http://localhost:4000/UoL/comp105/lectures/2020/11/30/2.html">&lt;h2 id=&quot;trees&quot;&gt;Trees&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
a[ ] --&amp;gt; b[ ]
a --&amp;gt; c[ ]
b --&amp;gt; d[ ]
b --&amp;gt; e[ ]
d --&amp;gt; f[ ]
d --&amp;gt; g[ ]
c --&amp;gt; h[ ]
c --&amp;gt; i[ ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A tree is composed of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Leaf nodes.
    &lt;ul&gt;
      &lt;li&gt;Leaves have no children.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Branch nodes.
    &lt;ul&gt;
      &lt;li&gt;Has a child which is a leaf.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;a-tree-type-in-haskell&quot;&gt;A Tree Type in Haskell&lt;/h3&gt;
&lt;p&gt;Any binary tree can be represented in this data type.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Tree&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Tree&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
a[ ] --&amp;gt; b[ ]
a --&amp;gt; c[ ]
c --&amp;gt; h[ ]
c --&amp;gt; i[ ]
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;recursion-on-trees&quot;&gt;Recursion on Trees&lt;/h3&gt;
&lt;p&gt;We can write recursive function that process tress.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Usually the recursive case will process both branches.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This function counts all the nodes in a tree:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;info&quot;&gt;For trees usually the base case is the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Leaf&lt;/code&gt; and the recursive rule operates on the two sub-trees of the branch node.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;trees-with-data&quot;&gt;Trees with Data&lt;/h2&gt;
&lt;p&gt;Nodes in a tree often hold data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
9 --&amp;gt; 4
4 --&amp;gt; 1
4 --&amp;gt; 6
1 --&amp;gt; 10 
1 --&amp;gt; 7
2 --&amp;gt; 3 
2 --&amp;gt; 0
9 --&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;type-of-trees-with-data&quot;&gt;Type of Trees with Data&lt;/h3&gt;
&lt;p&gt;This type allows each branch and leaf to have data of a single type associated with it:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
             &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
             &lt;span class=&quot;kr&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
1 --&amp;gt; 7
7 --&amp;gt; 2 
7 --&amp;gt; 9
1 --&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;recursion-on-trees-with-data&quot;&gt;Recursion on Trees with Data&lt;/h3&gt;
&lt;p&gt;This function adds together the numbers from all the branches and leaves in a tree with data.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;tree_sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Num&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tree_sum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tree_sum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree_sum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree_sum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree_sum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;example---fibonacci-numbers&quot;&gt;Example - Fibonacci Numbers&lt;/h4&gt;
&lt;p&gt;Before we used this code to calculate the Fibonacci numbers. This is slow due to the large amount of branching:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
A[fib 4] --&amp;gt; B[fib 3]
A --&amp;gt; C[fib 2]
B --&amp;gt; D[fib 2]
B --&amp;gt; E[fib 1]
D --&amp;gt; F[fib 1]
D --&amp;gt; G[fib 0]
C --&amp;gt; H[fib 1]
C --&amp;gt; I[fib 0]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;how-many-recursive-calls-does-the-code-make&quot;&gt;How many recursive calls does the code make?&lt;/h5&gt;
&lt;p&gt;We can make a function to build the call tree.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Tree&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Branch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is the same structure  as the tree at the top of the example.&lt;/p&gt;

&lt;p&gt;To count the nodes in this tree we can use the function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size&lt;/code&gt; from earlier:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;fib_calls&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib_tree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib_calls&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;177&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib_calls&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;21891&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib_calls&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2692537&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As we can see multiple recursion can be very slow if used incorrectly.&lt;/p&gt;

&lt;h4 id=&quot;example---finding-a-file&quot;&gt;Example - Finding a File&lt;/h4&gt;
&lt;p&gt;Suppose that we have a directory structure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
h[&quot;~/&quot;] --&amp;gt; d[docs/]
d --&amp;gt; a[a.txt]
d --&amp;gt; b[b.txt]
h --&amp;gt; c[c.txt]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Write a function that, given a filename, finds the path to that file.&lt;/p&gt;

&lt;p&gt;We can formulate the files as a data tree:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;~/&quot;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;docs/&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;a.txt&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;b.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;c.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p class=&quot;info&quot;&gt;This is the same as the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DTree&lt;/code&gt; above.&lt;/p&gt;

&lt;p&gt;Note that the file might not exist:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;So we will use the maybe type.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_file&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;a.txt&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;home/docs/a.txt&quot;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_file&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;d.txt&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fs&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;implementation&quot;&gt;Implementation&lt;/h5&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;find_file&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Dleaf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherwise&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;
    
&lt;span class=&quot;n&quot;&gt;find_file&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;let&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_file&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_file&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;of&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This implementation has two cases, one for the leaf and one for the branch.&lt;/p&gt;

&lt;h2 id=&quot;exercises&quot;&gt;Exercises&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;leafSum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DTree&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;leafSum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;leafSum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leafSum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leafSum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;treeElem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Eq&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DTree&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Bool&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;treeElem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DLeaf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;treeElem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;DBranch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;treeElem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;treeElem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP105" /><category term="Lectures" /><category term="COMP105" /><category term="Lectures" /><summary type="html">Trees graph TD a[ ] --&amp;gt; b[ ] a --&amp;gt; c[ ] b --&amp;gt; d[ ] b --&amp;gt; e[ ] d --&amp;gt; f[ ] d --&amp;gt; g[ ] c --&amp;gt; h[ ] c --&amp;gt; i[ ] A tree is composed of: Leaf nodes. Leaves have no children. Branch nodes. Has a child which is a leaf. A Tree Type in Haskell Any binary tree can be represented in this data type. data Tree = Leaf | Branch Tree Tree deriving(Show) graph TD a[ ] --&amp;gt; b[ ] a --&amp;gt; c[ ] c --&amp;gt; h[ ] c --&amp;gt; i[ ] Branch Leaf (Branch Leaf Leaf) Recursion on Trees We can write recursive function that process tress. Usually the recursive case will process both branches. This function counts all the nodes in a tree: size :: Tree -&amp;gt; Int size (Leaf) = 1 size (Branch x y) = 1 +size x + size y For trees usually the base case is the Leaf and the recursive rule operates on the two sub-trees of the branch node. &amp;gt; size (Branch Leaf (Branch Leaf Leaf)) 5 Trees with Data Nodes in a tree often hold data. graph TD 9 --&amp;gt; 4 4 --&amp;gt; 1 4 --&amp;gt; 6 1 --&amp;gt; 10 1 --&amp;gt; 7 2 --&amp;gt; 3 2 --&amp;gt; 0 9 --&amp;gt; 2 Type of Trees with Data This type allows each branch and leaf to have data of a single type associated with it: data DTree a = DLeaf a | DBranch a (DTree a) (DTree a) deriving (Show) graph TD 1 --&amp;gt; 7 7 --&amp;gt; 2 7 --&amp;gt; 9 1 --&amp;gt; 4 DBranch 1 (DBranch 7 (DLeaf 2) (DLeaf 9)) (DLeaf 4) Recursion on Trees with Data This function adds together the numbers from all the branches and leaves in a tree with data. tree_sum :: Num a =&amp;gt; DTree a -&amp;gt; a tree_sum (DLeaf x) = x tree_sum (DBranch x 1 l) = x + tree_sum l + tree_sum r &amp;gt; tree_sum (DBranch 1 (DBranch 7 (DLeaf 2) (DLeaf 9)) (DLeaf 4)) 22 Example - Fibonacci Numbers Before we used this code to calculate the Fibonacci numbers. This is slow due to the large amount of branching: fib 0 = 0 fib 1 = 1 fib n = fib (n-1) + fib (n-2) graph TD A[fib 4] --&amp;gt; B[fib 3] A --&amp;gt; C[fib 2] B --&amp;gt; D[fib 2] B --&amp;gt; E[fib 1] D --&amp;gt; F[fib 1] D --&amp;gt; G[fib 0] C --&amp;gt; H[fib 1] C --&amp;gt; I[fib 0] How many recursive calls does the code make? We can make a function to build the call tree. fib_tree :: Int -&amp;gt; Tree fib_tree 0 = Leaf fib_tree 1 = Leaf fib_tree n = Branch (fib_tree (n-1)) (fib_tree (n-2)) &amp;gt; fib_tree 4 Branch (Branch (Branch Leaf Leaf) Leaf) (Branch Leaf Leaf) This is the same structure as the tree at the top of the example. To count the nodes in this tree we can use the function size from earlier: fib_calls n = size (fib_tree n) &amp;gt; fib_calls 10 177 &amp;gt; fib_calls 20 21891 &amp;gt;fib_calls 30 2692537 As we can see multiple recursion can be very slow if used incorrectly. Example - Finding a File Suppose that we have a directory structure: graph TD h[&quot;~/&quot;] --&amp;gt; d[docs/] d --&amp;gt; a[a.txt] d --&amp;gt; b[b.txt] h --&amp;gt; c[c.txt] Write a function that, given a filename, finds the path to that file. We can formulate the files as a data tree: let fs = DBranch &quot;~/&quot; (DBranch &quot;docs/&quot; (DLeaf &quot;a.txt&quot; ) (DLeaf &quot;b.txt&quot;)) (DLeaf &quot;c.txt&quot;) This is the same as the DTree above. Note that the file might not exist: So we will use the maybe type. &amp;gt; find_file &quot;a.txt&quot; fs Just &quot;home/docs/a.txt&quot; &amp;gt; find_file &quot;d.txt&quot; fs Nothing Implementation find_file file (Dleaf x) | x == file = Just file | otherwise = Nothing find_file file (DBranch x l r) = let left = find_file l right = find_file r in case (left, right) of (Just y, _) -&amp;gt; Just (x ++ y) (_, Just y) -&amp;gt; Just (x ++ y) (_, _) -&amp;gt; Nothing This implementation has two cases, one for the leaf and one for the branch. Exercises leafSum :: DTree Int -&amp;gt; Int leafSum (DLeaf x) = x leafSum (DBranch _ l r) = leafSum l + leafSum r treeElem :: Eq a =&amp;gt; a -&amp;gt; DTree a -&amp;gt; Bool treeElem x (DLeaf y) = x == y treeElem x (DBranch y l r) = (x == y) || treeElem x l || treeElem x r</summary></entry><entry><title type="html">COMP109 - Logic - 1</title><link href="http://localhost:4000/UoL/comp109/lectures/2020/11/30/1.html" rel="alternate" type="text/html" title="COMP109 - Logic - 1" /><published>2020-11-30T00:00:00+00:00</published><updated>2020-11-30T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp109/lectures/2020/11/30/1</id><content type="html" xml:base="http://localhost:4000/UoL/comp109/lectures/2020/11/30/1.html">&lt;p class=&quot;info&quot;&gt;This topic is very similar to the subjects covered in COMP111’s &lt;a href=&quot;/UoL/comp111/lectures/2020-11-12-1&quot;&gt;propositional logic&lt;/a&gt;. As result I will only be noting down significant differences.&lt;/p&gt;

&lt;p&gt;Logic is concerned with the truth a falsity of statements. The question is when does a statement follow from a set of statements.&lt;/p&gt;

&lt;h2 id=&quot;propositional-logic&quot;&gt;Propositional Logic&lt;/h2&gt;
&lt;p&gt;Propositional logic is logic which only concerns itself with whether something is true or false. Other languages differ themselves as they deal with uncertainties.&lt;/p&gt;

&lt;p&gt;A proposition is a statement that can either be true or false. A statement like \(4+5\) is not a proposition as it doesn’t give a true or false answer.&lt;/p&gt;

&lt;h3 id=&quot;compound-propositions&quot;&gt;Compound Propositions&lt;/h3&gt;
&lt;p&gt;More complex propositions are formed using logical connectives (also called Boolean connectives).&lt;/p&gt;

&lt;p&gt;The basic connectives are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;\(\neg\): Negation (read “not”).&lt;/li&gt;
  &lt;li&gt;\(\wedge\): Conjunction (read “and”).&lt;/li&gt;
  &lt;li&gt;\(\vee\): Disjunction (read “or”).
    &lt;ul&gt;
      &lt;li&gt;These are the scientific names and they make a difference between the english and mathematical words.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;\(\Rightarrow\): Implication (read “if…then”).
    &lt;ul&gt;
      &lt;li&gt;In other schools this may be written as \(\rightarrow\) or as \(\subseteq\).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;\(\Leftrightarrow\): Equivalence (read “if, and only if,”).
    &lt;ul&gt;
      &lt;li&gt;Similar to 4. the notation is not as set as 1,2 and 3. This may be written as \(\leftrightarrow\) or \(\equiv\).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Propositional formed using these logical connectives are called compound propositions; otherwise atomic propositions.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A propositional formula is either an atom ic or compound proposition.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP109" /><category term="Lectures" /><category term="COMP109" /><category term="Lectures" /><summary type="html">This topic is very similar to the subjects covered in COMP111’s propositional logic. As result I will only be noting down significant differences. Logic is concerned with the truth a falsity of statements. The question is when does a statement follow from a set of statements. Propositional Logic Propositional logic is logic which only concerns itself with whether something is true or false. Other languages differ themselves as they deal with uncertainties. A proposition is a statement that can either be true or false. A statement like \(4+5\) is not a proposition as it doesn’t give a true or false answer. Compound Propositions More complex propositions are formed using logical connectives (also called Boolean connectives). The basic connectives are: \(\neg\): Negation (read “not”). \(\wedge\): Conjunction (read “and”). \(\vee\): Disjunction (read “or”). These are the scientific names and they make a difference between the english and mathematical words. \(\Rightarrow\): Implication (read “if…then”). In other schools this may be written as \(\rightarrow\) or as \(\subseteq\). \(\Leftrightarrow\): Equivalence (read “if, and only if,”). Similar to 4. the notation is not as set as 1,2 and 3. This may be written as \(\leftrightarrow\) or \(\equiv\). Propositional formed using these logical connectives are called compound propositions; otherwise atomic propositions. A propositional formula is either an atom ic or compound proposition.</summary></entry><entry><title type="html">COMP109 - Logic - 2</title><link href="http://localhost:4000/UoL/comp109/lectures/2020/11/30/2.html" rel="alternate" type="text/html" title="COMP109 - Logic - 2" /><published>2020-11-30T00:00:00+00:00</published><updated>2020-11-30T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp109/lectures/2020/11/30/2</id><content type="html" xml:base="http://localhost:4000/UoL/comp109/lectures/2020/11/30/2.html">&lt;p class=&quot;info&quot;&gt;This lecture is very similar to COMP111’s &lt;a href=&quot;/UoL/comp111/lectures/2020-11-12-2&quot;&gt;truth values&lt;/a&gt; lecture. View that lecture for all truth tables.&lt;/p&gt;

&lt;h2 id=&quot;truth-values&quot;&gt;Truth Values&lt;/h2&gt;
&lt;p&gt;Interpretations are a way of assigning values to propositions which may vary depending on the situation or person who answers them.&lt;/p&gt;

&lt;p&gt;An interpretation \(I\) is a function which assigns to any atomic proposition \(p_i\) a truth value:&lt;/p&gt;

&lt;p&gt;\[I(p_i)\in \{0,1\}\]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If \(I(p_i)=1\), then \(p_i\) is called &lt;strong&gt;true&lt;/strong&gt; under the interpretation \(I\).&lt;/li&gt;
  &lt;li&gt;If \(I(p_i)=0\), then \(p_i\) is called &lt;strong&gt;false&lt;/strong&gt; under the interpretation \(I\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an assignment \(I\) we can compute the truth value of compute formulas step by step using so-called truth tables.&lt;/p&gt;

&lt;h3 id=&quot;implication&quot;&gt;Implication&lt;/h3&gt;

&lt;p&gt;The implication \((P\Rightarrow Q)\) of \(P\)  and \(Q\):
 \[\text{If } P \text{ then } Q\]&lt;/p&gt;

&lt;h4 id=&quot;truth-table&quot;&gt;Truth Table&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(P\)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(Q\)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\((P\Rightarrow Q)\)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Consider this table with the proposition \(P\) being a promise. If you don’t make a promise but you fulfil it anyway then you aren’t breaking that promise.&lt;/p&gt;

&lt;p&gt;Another example would be the following statement:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If a number is divisible by 6 then it is divisible by 3.
    &lt;ul&gt;
      &lt;li&gt;If it is not divisible by 6 but still divides by 3, this does not invalidate the proposition.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP109" /><category term="Lectures" /><category term="COMP109" /><category term="Lectures" /><summary type="html">This lecture is very similar to COMP111’s truth values lecture. View that lecture for all truth tables. Truth Values Interpretations are a way of assigning values to propositions which may vary depending on the situation or person who answers them. An interpretation \(I\) is a function which assigns to any atomic proposition \(p_i\) a truth value: \[I(p_i)\in \{0,1\}\] If \(I(p_i)=1\), then \(p_i\) is called true under the interpretation \(I\). If \(I(p_i)=0\), then \(p_i\) is called false under the interpretation \(I\). Given an assignment \(I\) we can compute the truth value of compute formulas step by step using so-called truth tables. Implication The implication \((P\Rightarrow Q)\) of \(P\) and \(Q\): \[\text{If } P \text{ then } Q\] Truth Table \(P\) \(Q\) \((P\Rightarrow Q)\) 1 1 1 1 0 0 0 1 1 0 0 1 Consider this table with the proposition \(P\) being a promise. If you don’t make a promise but you fulfil it anyway then you aren’t breaking that promise. Another example would be the following statement: If a number is divisible by 6 then it is divisible by 3. If it is not divisible by 6 but still divides by 3, this does not invalidate the proposition.</summary></entry><entry><title type="html">COMP107 - Tutorial 4</title><link href="http://localhost:4000/UoL/comp107/tutorials/2020/11/27/1.html" rel="alternate" type="text/html" title="COMP107 - Tutorial 4" /><published>2020-11-27T00:00:00+00:00</published><updated>2020-11-27T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp107/tutorials/2020/11/27/1</id><content type="html" xml:base="http://localhost:4000/UoL/comp107/tutorials/2020/11/27/1.html">&lt;h2 id=&quot;er-by-view-integration&quot;&gt;ER by View Integration&lt;/h2&gt;

&lt;p&gt;You should consider each user perspective separately.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Requirements are given for many users groups or applications independently.&lt;/li&gt;
  &lt;li&gt;an ER schema is designed  for each user group and application (typically by different developers.)&lt;/li&gt;
  &lt;li&gt;Individual views are merged into a global conceptual schema.&lt;/li&gt;
  &lt;li&gt;Individual views can be reconstructed as external schema after view integration.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;view-integration&quot;&gt;View Integration&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Identification of correspondences and conflicts among schema.
    &lt;ul&gt;
      &lt;li&gt;Need to identify constructs in schemas that represent the same real-world concept.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Modification of views to conform to one another.
    &lt;ul&gt;
      &lt;li&gt;Some of the view schemas may need to be refined to resolve conflicts identified in 1.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Merging of views.
    &lt;ul&gt;
      &lt;li&gt;Global schema is created by merging individual schemas.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Restructuring.
    &lt;ul&gt;
      &lt;li&gt;Global schema may require further refinement to remove redundancies or unnecessary complexity.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;example&quot;&gt;Example&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;In the example we put up all the diagrams next to each other to view the conflicts. They include:
    &lt;ul&gt;
      &lt;li&gt;Names (including synonyms).
        &lt;ul&gt;
          &lt;li&gt;Homonyms - Using the same name for different things.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Notions
        &lt;ul&gt;
          &lt;li&gt;Where concepts are represented as entities or attributes.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;From this you change each view individually to make them coherent with each other.&lt;/li&gt;
  &lt;li&gt;After this you eliminate redundancies to make them into a single diagram.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;task&quot;&gt;Task&lt;/h3&gt;
&lt;p&gt;Draw and ER or EER model to describe a library by using a view integration approach.&lt;/p&gt;

&lt;p&gt;The group made this in the first phase:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/UoL/assets/COMP107/Tutorials/2020-11-27-1-1.svg&quot; alt=&quot;1st Phase&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;warning&quot;&gt;We should stick very specifically to the story. Over-designing is bad for other people’s designs and you should stick to only the points in your story.&lt;/p&gt;

&lt;p class=&quot;error&quot;&gt;The subject of the user story &lt;strong&gt;does not&lt;/strong&gt; need to be included in the diagram. This is because they are the user and don’t need data stored about them to use the database.&lt;/p&gt;

&lt;p&gt;The group made this in the second phase.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/UoL/assets/COMP107/Tutorials/2020-11-27-1-2.svg&quot; alt=&quot;1st Phase&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;error&quot;&gt;Attributes should not be shared between different entities.&lt;/p&gt;

&lt;p class=&quot;error&quot;&gt;The attribute course should be an entity and not a complex attribute. This would make a student enrolled in many courses.&lt;/p&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP107" /><category term="Tutorials" /><category term="COMP107" /><category term="Tutorials" /><summary type="html">ER by View Integration You should consider each user perspective separately. Requirements are given for many users groups or applications independently. an ER schema is designed for each user group and application (typically by different developers.) Individual views are merged into a global conceptual schema. Individual views can be reconstructed as external schema after view integration. View Integration Identification of correspondences and conflicts among schema. Need to identify constructs in schemas that represent the same real-world concept. Modification of views to conform to one another. Some of the view schemas may need to be refined to resolve conflicts identified in 1. Merging of views. Global schema is created by merging individual schemas. Restructuring. Global schema may require further refinement to remove redundancies or unnecessary complexity. Example In the example we put up all the diagrams next to each other to view the conflicts. They include: Names (including synonyms). Homonyms - Using the same name for different things. Notions Where concepts are represented as entities or attributes. From this you change each view individually to make them coherent with each other. After this you eliminate redundancies to make them into a single diagram. Task Draw and ER or EER model to describe a library by using a view integration approach. The group made this in the first phase: We should stick very specifically to the story. Over-designing is bad for other people’s designs and you should stick to only the points in your story. The subject of the user story does not need to be included in the diagram. This is because they are the user and don’t need data stored about them to use the database. The group made this in the second phase. Attributes should not be shared between different entities. The attribute course should be an entity and not a complex attribute. This would make a student enrolled in many courses.</summary></entry><entry><title type="html">COMP109 - Relations - 9</title><link href="http://localhost:4000/UoL/comp109/lectures/2020/11/27/1.html" rel="alternate" type="text/html" title="COMP109 - Relations - 9" /><published>2020-11-27T00:00:00+00:00</published><updated>2020-11-27T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp109/lectures/2020/11/27/1</id><content type="html" xml:base="http://localhost:4000/UoL/comp109/lectures/2020/11/27/1.html">&lt;h2 id=&quot;partial-orders&quot;&gt;Partial Orders&lt;/h2&gt;
&lt;p&gt;A binary relation \(R\) on set \(A\) which is reflexive, transitive and antisymmetric is called  a partial order.&lt;/p&gt;

&lt;p&gt;Partial orders are important in situations where we wish to characterise precedence.&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;The relation \(\leq\) on the set of \(\Bbb{R}\) of real numbers.&lt;/li&gt;
  &lt;li&gt;The relation \(\subseteq\) on \(\text{Pow}(A)\).&lt;/li&gt;
  &lt;li&gt;“Is a divisor of” on the set \(\Bbb{Z^+}\) of positive integers.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;example---job-scheduling&quot;&gt;Example - Job Scheduling&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Task&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Immediate Dependencies&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2, 3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2, 3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4, 5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6, 7, 8&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph LR
1[Task 1 - 7 Hours] --&amp;gt; 2[Task 2 - 6 Hours]
1 --&amp;gt; 3[Task 3 - 3 Hours]
2 --&amp;gt; 4[Task 4 - 6 Hours]
2 --&amp;gt; 5[Task 5 - 3 Hours]
3 --&amp;gt; 5
4 --&amp;gt; 6[Task 6 - 1 Hour]
2 --&amp;gt; 7[Task 7 - 1 Hour]
3 --&amp;gt; 7
4 --&amp;gt; 8[Task 8 - 2 Hours]
5 --&amp;gt; 8
6 --&amp;gt; 9[Task 9 - 5 Hours]
7 --&amp;gt; 9
8 --&amp;gt; 9
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;predecessors-in-partial-orders&quot;&gt;Predecessors in Partial Orders&lt;/h3&gt;
&lt;p&gt;if \(R\) is a partial order on a set \(A\) and \(xRy, x\neq y\) we call \(x\) a &lt;strong&gt;predecessor&lt;/strong&gt; of \(y\).&lt;/p&gt;

&lt;p&gt;If \(x\) is a predecessor of \(y\) and there is no \(z\in\{x,y\}\) for which \(xRy\) and \(zRy\), we call \(x\) and &lt;strong&gt;immeditate predecessor&lt;/strong&gt; of \(y\).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph LR
subgraph R
y -.-&amp;gt; z
z -.-&amp;gt; x
x --&amp;gt; y
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;info&quot;&gt;In this graph if you can see no \(z\) in-between \(x\) and \(y\) then \(y\) is an immediate predecessor of \(x\).&lt;/p&gt;

&lt;h4 id=&quot;integer-example&quot;&gt;Integer Example&lt;/h4&gt;
&lt;p&gt;For the function \(\leq\) on the set \(\Bbb{Z}\) the immediate predecessor of a number \(n\) is \(n-1\).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph LR
subgraph Z
1[n-1] --&amp;gt; 2[n]
end 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;hasse-diagram&quot;&gt;Hasse Diagram&lt;/h4&gt;
&lt;p&gt;The Hasse Diagram of a partial order is a digraph. The vertices of the digraph are the elements of the partial order, and the edges of the digraph are given by the “immediate predecessor” relation.&lt;/p&gt;

&lt;p&gt;This is an example for the bit vector representation of a set containing 3 elements. Each relation is a subset relation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph BT
0[0,0,0] --- 1[0,0,1]
0 --- 2[0,1,0]
0 --- 4[1,0,0]
1 --- 3[0,1,1]
1 --- 5[1,0,1]
2 --- 3
2 --- 6[1,1,0]
4 --- 5
4 --- 6
3 --- 7[1,1,1]
5 --- 7
6 --- 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;info&quot;&gt;It is typical to assume that the arrow pointing upwards.&lt;/p&gt;

&lt;p&gt;This diagram notation saves us from having to draw all the reflexive links and also all of the dependency links by just drawing the &lt;strong&gt;immediate dependency&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;total-orders&quot;&gt;Total Orders&lt;/h2&gt;
&lt;p&gt;A binary relation \(R\) on a set \(A\) is a total order if it is a partial order such that any \(x,y\in A,xRy\) or \(yRx\).&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;This means that for any relation you can always compare them.&lt;/p&gt;

&lt;p&gt;The Hasse diagram of a total order is a chain.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;This means that there are no splits as splits mean that they aren’t comparable.&lt;/p&gt;

&lt;h3 id=&quot;examples-1&quot;&gt;Examples&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;The relation \(\leq\) on the set \(\Bbb{R}\) of real numbers.&lt;/li&gt;
  &lt;li&gt;The usual lexicographical ordering on words in a dictionary.&lt;/li&gt;
  &lt;li&gt;The relation “is a divisor of” is &lt;strong&gt;not&lt;/strong&gt; a total order.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP109" /><category term="Lectures" /><category term="COMP109" /><category term="Lectures" /><summary type="html">Partial Orders A binary relation \(R\) on set \(A\) which is reflexive, transitive and antisymmetric is called a partial order. Partial orders are important in situations where we wish to characterise precedence. Examples The relation \(\leq\) on the set of \(\Bbb{R}\) of real numbers. The relation \(\subseteq\) on \(\text{Pow}(A)\). “Is a divisor of” on the set \(\Bbb{Z^+}\) of positive integers. Example - Job Scheduling Task Immediate Dependencies 1   2 1 3 1 4 2 5 2, 3 6 4 7 2, 3 8 4, 5 9 6, 7, 8 graph LR 1[Task 1 - 7 Hours] --&amp;gt; 2[Task 2 - 6 Hours] 1 --&amp;gt; 3[Task 3 - 3 Hours] 2 --&amp;gt; 4[Task 4 - 6 Hours] 2 --&amp;gt; 5[Task 5 - 3 Hours] 3 --&amp;gt; 5 4 --&amp;gt; 6[Task 6 - 1 Hour] 2 --&amp;gt; 7[Task 7 - 1 Hour] 3 --&amp;gt; 7 4 --&amp;gt; 8[Task 8 - 2 Hours] 5 --&amp;gt; 8 6 --&amp;gt; 9[Task 9 - 5 Hours] 7 --&amp;gt; 9 8 --&amp;gt; 9 Predecessors in Partial Orders if \(R\) is a partial order on a set \(A\) and \(xRy, x\neq y\) we call \(x\) a predecessor of \(y\). If \(x\) is a predecessor of \(y\) and there is no \(z\in\{x,y\}\) for which \(xRy\) and \(zRy\), we call \(x\) and immeditate predecessor of \(y\). graph LR subgraph R y -.-&amp;gt; z z -.-&amp;gt; x x --&amp;gt; y end In this graph if you can see no \(z\) in-between \(x\) and \(y\) then \(y\) is an immediate predecessor of \(x\). Integer Example For the function \(\leq\) on the set \(\Bbb{Z}\) the immediate predecessor of a number \(n\) is \(n-1\). graph LR subgraph Z 1[n-1] --&amp;gt; 2[n] end Hasse Diagram The Hasse Diagram of a partial order is a digraph. The vertices of the digraph are the elements of the partial order, and the edges of the digraph are given by the “immediate predecessor” relation. This is an example for the bit vector representation of a set containing 3 elements. Each relation is a subset relation: graph BT 0[0,0,0] --- 1[0,0,1] 0 --- 2[0,1,0] 0 --- 4[1,0,0] 1 --- 3[0,1,1] 1 --- 5[1,0,1] 2 --- 3 2 --- 6[1,1,0] 4 --- 5 4 --- 6 3 --- 7[1,1,1] 5 --- 7 6 --- 7 It is typical to assume that the arrow pointing upwards. This diagram notation saves us from having to draw all the reflexive links and also all of the dependency links by just drawing the immediate dependency. Total Orders A binary relation \(R\) on a set \(A\) is a total order if it is a partial order such that any \(x,y\in A,xRy\) or \(yRx\). This means that for any relation you can always compare them. The Hasse diagram of a total order is a chain. This means that there are no splits as splits mean that they aren’t comparable. Examples The relation \(\leq\) on the set \(\Bbb{R}\) of real numbers. The usual lexicographical ordering on words in a dictionary. The relation “is a divisor of” is not a total order.</summary></entry><entry><title type="html">COMP109 - Relations - 10</title><link href="http://localhost:4000/UoL/comp109/lectures/2020/11/27/2.html" rel="alternate" type="text/html" title="COMP109 - Relations - 10" /><published>2020-11-27T00:00:00+00:00</published><updated>2020-11-27T00:00:00+00:00</updated><id>http://localhost:4000/UoL/comp109/lectures/2020/11/27/2</id><content type="html" xml:base="http://localhost:4000/UoL/comp109/lectures/2020/11/27/2.html">&lt;p&gt;All the relations we have been looking at so far have been binary relations however this can be generalised for greater numbered relations.&lt;/p&gt;

&lt;h2 id=&quot;n-ary-relations&quot;&gt;\(n\)-ary Relations&lt;/h2&gt;
&lt;p&gt;The Cartesian product \(A_1\times A_2\times \ldots \times A_n\) of sets \(A_1,A_2,\ldots,A_n\) is defined by:&lt;/p&gt;

&lt;p&gt;\[A_1\times A_2\times \ldots \times A_n=\{(a_1,\ldots,a_n)\ \vert\ a_1\in A_1,\ldots,a_n\in A_n\}\]&lt;/p&gt;

&lt;p&gt;Here \((a_1,\ldots,a_n)=(b_1,\ldots,b_n\) if and only if \(a_i=b_i\) for all \(1\leq i\leq n\).&lt;/p&gt;

&lt;p&gt;An \(n\)-ary relation is a subset of \(A_1\times\ldots A_n\)&lt;/p&gt;

&lt;h3 id=&quot;databases-and-relations&quot;&gt;Databases and Relations&lt;/h3&gt;
&lt;p&gt;A database table \(\approx\) relation.&lt;/p&gt;

&lt;h4 id=&quot;table-1-textstudents&quot;&gt;Table 1 \(\text{Students}\)&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Student_name&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;ID_number&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Major&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;GPA&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Ackermann&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;231455&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Computer Science&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.88&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Adams&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;888323&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Physics&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.45&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Chou&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;102147&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Computer Science&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.49&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Goodfriend&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;453876&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Mathematics&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.45&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Rao&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;678543&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Mathematics&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Stevens&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;786576&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Psychology&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2.99&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This student table is a subset of the Cartesian product of four sets containing names, ID numbers, subject and GPA. We can then write these properties in tuples in the subset:&lt;/p&gt;

&lt;p&gt;\[\text{Students}=\{\text{(Ackerman, 231455, Computer Science, 3.88)}\ldots\}\]&lt;/p&gt;

&lt;h2 id=&quot;unary-relations&quot;&gt;Unary Relations&lt;/h2&gt;
&lt;p&gt;Unary relation are just subsets of a set.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;The unary relation \(\text{EvenPositiveIntegers}\) on the set \(\Bbb{Z^+}\) of positive integers is:&lt;/p&gt;

&lt;p&gt;\[\{x\in\Bbb{Z^+}\ \vert\ x \text{ is even}\}\]&lt;/p&gt;

&lt;p&gt;This shows that a unary relation is just a list of items in a set the satisfy a property.&lt;/p&gt;</content><author><name>Ben Weston</name><email>b.weston60@gmail.com</email></author><category term="COMP109" /><category term="Lectures" /><category term="COMP109" /><category term="Lectures" /><summary type="html">All the relations we have been looking at so far have been binary relations however this can be generalised for greater numbered relations. \(n\)-ary Relations The Cartesian product \(A_1\times A_2\times \ldots \times A_n\) of sets \(A_1,A_2,\ldots,A_n\) is defined by: \[A_1\times A_2\times \ldots \times A_n=\{(a_1,\ldots,a_n)\ \vert\ a_1\in A_1,\ldots,a_n\in A_n\}\] Here \((a_1,\ldots,a_n)=(b_1,\ldots,b_n\) if and only if \(a_i=b_i\) for all \(1\leq i\leq n\). An \(n\)-ary relation is a subset of \(A_1\times\ldots A_n\) Databases and Relations A database table \(\approx\) relation. Table 1 \(\text{Students}\) Student_name ID_number Major GPA Ackermann 231455 Computer Science 3.88 Adams 888323 Physics 3.45 Chou 102147 Computer Science 3.49 Goodfriend 453876 Mathematics 3.45 Rao 678543 Mathematics 3.9 Stevens 786576 Psychology 2.99 This student table is a subset of the Cartesian product of four sets containing names, ID numbers, subject and GPA. We can then write these properties in tuples in the subset: \[\text{Students}=\{\text{(Ackerman, 231455, Computer Science, 3.88)}\ldots\}\] Unary Relations Unary relation are just subsets of a set. Example The unary relation \(\text{EvenPositiveIntegers}\) on the set \(\Bbb{Z^+}\) of positive integers is: \[\{x\in\Bbb{Z^+}\ \vert\ x \text{ is even}\}\] This shows that a unary relation is just a list of items in a set the satisfy a property.</summary></entry></feed>