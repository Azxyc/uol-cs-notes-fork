---
title: COMP124 - Memory Management
tags: COMP124 Lectures
---
## Memory Addressing
The memory inside RAM can be viewed as a linear sequence of bytes, each with its own address.

* Addresses range from 0 up to the number of bytes available.
* Since addresses are stored in register and other variables, addressable space will depend on the bit-length of the CPU.
* 32-bit systems can address 4,294,967,296 bytes.
	* This is equivalent to 4GB.

## Memory
The value of the instruction pointer (IP) determines the next instruction to be fetches from memory by the CPU.

The execution of an instruction may lead to additional memory accesses.
{:.info}

Programs usually reside on disk as binary executable files.

In order for a program to be executed it must be brought into memory and run within a process.

When the process is executed it accesses data and instructions from memory; upon termination its memory space is freed up so it can be reused.

## Address Binding
Programs require addresses for instructions and data that they want to access. There are several ways of binding these addresses.

### Compile Time
This assumes that the program will always be loaded into the same memory address every time it is run.

These addresses are hard-coded into the binary.

### Load-Time Binding
Ideally, programs should be able to run anywhere in memory. To do this you could:

* Generate position-independent code (PIC)
	* Aided by using relative jump instructions.
	* `JUMP -15` or `JUMP +7
	* These are replaced by actual values at load time.
* If not binary program files can include a list of instruction addresses that need to be initialised by a loader.

This is static for the runtime of the program.
{:.info}

### Dynamic (Run-Time) Binding
This is the method used in modern systems:

* All programs are compiled to run at address zero.
* For programs with address space of size $n$ all addresses are in range $0$ to $n-1$.
	
	These are **logical** (virtual) addresses.
	{:.info}
* Mapping to physical addresses is handles at run-time by the CPU's **memory management unit** (MMU)
	* MMU had **relocation register** (**base register**) holding start addresses of processes.
* Virtual addresses are added on to the base value.

## Logical and Physical Adresses
Addresses generated by the CPU are known as **logical**/**virtual** addresses.
	
The set of all logical addresses generated by a program is known as the **logical address space**.
{:.info}

The addresses generated by the MMU are known as **physical addresses**.

The set of all physical addresses corresponding to the logical address is known as the **physical address space**.
{:.info}

* Compile and load time binding always produce the same logical and physical addresses.
* Run-time binding results in logical and physical addresses that are different.