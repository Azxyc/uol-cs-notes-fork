---
title: COMP201 - Software Testing
tags: COMP201 Lectures
---
There are additional examples of test cases [in the slides](https://liverpool.instructure.com/courses/46117/files/6013927?module_item_id=1189968).
{:.info}

## Test Plan Template

| Name of Case | Description | Input Data | Action | Expected Output | Actual Output | Pass |
| :-- | :-- | :-- | :-- | :-- | :-- | :-- |
| LoginOKPass | Tests login with a good username and password. | Username=test1<br>Password=pass1 | Click login. | OK | Login OK | True |
| | | | | | | |

## Black-Box Testing
This is a method of testing where we blindly test inputs and validate the outputs.

### Equivalence Partitioning
Often many inputs produce similar outputs (correct login produces a login event):

* We can then group the related inputs into an **equivalence partition**.

Testing data at the **edge** of the equivalence partition is more likely to produce errors.
{:.info}

## White-Box Testing (Structural Testing)
This form of testing uses knowledge of the program to identify additional test cases:

* The aim is to exercise all program statements (not all path combinations).

### Cyclomatic Complexity
We can represent the branches in the code as a graph where:

* Nodes - Branches
* Edges - Program Flow

The cyclomatic complexity of a **program graph** is:

$$
e -n+2
$$

* $e$ - The number of edges.
* $n$ - The number of nodes.

This represents the **number of tests** to test all control statements.