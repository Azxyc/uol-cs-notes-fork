---
title: Greedy Algorithm Applications - Knapsack, Scheduling, Clustering
tags: COMP202 Lectures
---
The **greedy method** solves optimisation problems by going through a sequence of feasible choices.

The sequence starts from a well-understood configuration and then iteratively makes the **decision that seems best** from all those that are **currently possible**.

Problems that have a greedy solution possess the **greedy-choice** property.
{:.info}

## Fractional Knapsack Problem
This is a variation of the [knapsack problem]({{site.baseurl}}/comp108/lectures/2021/04/21/1.html) where we are able to take arbitrary fractions of each item. The problem is formally defined like so:

Let $S$ be a set of $n$ items, where each item $i$ has a positive benefit $b_i$ and a positive weight $w_i$. Additionally, we are allowed to take arbitrary fractions $x_i$ of each item such that $0\leq x_i\leq w_i$.

**Goal** - Find the maximum benefit subset that does not exceeds the total weight $W$.

The total benefit of the items taken is determined by the sum:

$$
\sum_{i\in S}b_i\left(\frac{x_i}{w_i}\right)
$$

### Fractional Knapsack Method
The general method takes the following form:

1. Compute the **value index** for each item $i$ defined by:

	$$
	v_i=\frac{b_i}{w_i}
	$$
1. Select the items to include in the knapsack, starting with the **highest** value index.

We can implement this in the following pseudo-code:

fractionalKnapsack(S, W)

```
for i = 1 to |S| do
	xi = 0
	vi = bi / wi
	insert(vi, i) into heap H	// max value at root

w = o
while w < W do
	Remove the max value from H
	a = min(wi, W - w)
	xi = a
	w = w + a
```

* Input - Set of $S$ items, item $i$ has weight $w_i$ and benefit $b_i$; maximum total weight $W$.
* Output - Amount $x_i$ of each item to maximise the total benefit.

### Time Complexity of Fractional Knapsack Problem

1. Using a heap, with the maximum at the root, we can compute the value indices and build the heap in $O(n\log n)$ time.
1. Then, each greedy choice, which removes an item with the greatest remain value index, requires $O(\log n)$ time.

### The {0, 1} - Knapsack Problem
This is the same knapsack problem that was discussed in COMP208 - [Greedy Algorithm - 1 - Knapsack Problem]({{site.baseurl}}/comp108/lectures/2021/04/21/1.html) where you cannot take fractions of items.

As discussed in that lecture, the greedy method will not find an optimal solution to this problem. To solve this we can use a dynamic programming approach instead.

To be continued.
{:.error}

![Work in Progress](http://gifgifs.com/animations/jobs-people/construction-and-maintenance/Man_with_jackhammer.gif)