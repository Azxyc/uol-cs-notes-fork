---
title: Introduction to C#
tags: COMP282 Lectures
---
C# is a fully managed language (like Java). Memory is garbage collected and the compiler handles the allocation of resources automatically. 

## Hello, world!

A hello world program would look something like so:

```c#
using System;
class Hello {
	static void Main(string[] args) {
		Console.WriteLine("Hello World!");
	}
}
```

## Getters & Setters in C#
Getters and setters are used like so in C#:

```c#
class Person {
	private string _name;
	public string Name {
		get {
			return _name;
		}
		set {
			_name = value;
		}
	}
}
class Program {
	public static void Main(string [] args) {
		Person p = new Person();
		p.Name = "Charles";
		System.Console.WriteLine(p.Name);
	}
}
```

It is convention that private variables start with `_`.
{:.info}

### `private` Getters & Setters
Using one of these outside of the scope of the class will result in a compilation error:

```c#
class Person {
	private string _name;
	public string Name {
		private get {
			return _name;
		}
		private set {
			_name = value;
		}
	}
}
```

## Interfaces in C#
C# has interfaces like in Java. We can make and use them like so:

```c#
using System;
class Program : IBla {
	static void Main(string[] args) {
		Console.WriteLine("Hello World!");
	}
}
interface IBla {
	bool test();
}
```

## Inheritance in C#
Inheritance in C# is similar to in C++:

```c#
using System;
class Program : Bla {
	static void Main(string[] args) {
		Console.WriteLine("Hello World!");
	}
}
class Bla {
	public bool test() {
		return true;
	}
}
```

### Constructors in C#
Constructors look like so in C#:

```c#
using System;
class Program : Bla {
	public Program(int b) : base(b) {}
	public Program() : this(0) {}
}
class Bla {
	public Bla(int a) {}
}
```

* `base` is used to refer to the class we inherit (`Bla`).
* `this` is used to refer to the current class (`Program`).

### Inheritance & Interfaces in C#
We can declare both interfaces and inheritance at once:

```c#
using System;
class Program : Bla, IBla {
	static void Main(string[] args) {
		Console.WriteLine("Hello World!");
	}	
}
interface IBla {
	bool test();
}
class Bla {
	public bool test() {
		return true;
	}
}
```

The class must be listed before any interfaces.
{:.warning}

## Polymorphism in C#
Polymorphism is similar to C++:

```c#
using System;
class Program : Bla {
	public override bool test() {
		return false;
	}
}
class Bla {
	public virtual bool test() {
		return true;
	}
}
```

Our methods can be set in three ways:

* Using both `virtual` and `override`:
	* This will override as expected.
* Without `virtual` or `override`:
	* This will take the function of the parent.
* With both `abstract`:
	* This works similarly to in Java.
	
## Access Modifiers in C#
We have the standard access modifiers:

* `public`
* `private`
* `protected`

We also have access modifiers that are used to inform that creation of `.dll` files:

* `internal` - Only from the same compilation.
	* If you compile to a `.dll` or `.exe` file, you can only access these from `.cs` files used to compile it.
* `protected` or `internal` - From the same compilation or from children.
* `protected internal` - From children in the same compilation.

## Overloading in C#
Generally people don't overload operators - instead of overloading `+` we make use `add()`. This will be shown anyway.

Requirements:

* Operator overloading must be defined in a class that defines one of the parameters.
* It must be `public` and `static` (meaning call-able from outside an object).

```c#
using System;
class Fraction {
	int n;
	int d;
	public Fraction(int n, int d) {
		this.n = n;
		this.d = d;
	}
	public static Fraction operator +(Fraction a) {
		return a;
	}
	public static Fraction operator +(Fraction a, Fraction b) {
		return new Fraction(a.d*b.n + b.d*a.n,a.d*b.d);
	}
}
```

If we overload `true` we must also overload `false`.
{:.info}